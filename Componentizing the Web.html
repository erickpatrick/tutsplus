<h1>Componentizando a Web</h1>

<p>Essa é uma história sobre um dos meus projetos. Um bem grande. Uma mistura entre <a href="http://php.net/">PHP</a> e <a href="http://nodejs.org/">Node.js</a>. É uma aplicação de página única (SPA) por um lado, e um site otimizado para buscas (SEO) por outro. Milhares de JavaScipt, CSS e HTML escritos. Em uma única palavra, um pesadelo em forma de código <em>spaghetti</em> para qualquer desenvolvedor. Houve altos e baixos. Produzindo e solucionando problemas. Lutando com as mais novas tecnologias, acabamos com uma biblioteca simples e maravilhosa, que será o tópico desse artigo</p>

<h2>O Começo</h2>

<p>Como sempre acontece, o projeto não foi considerado grande. Recebemos o resumo do encontro com o cliente, discutimos sobre como o desenvolvimento seria levado, que tecnologias seria utilizadas e como as utilizaríamos. Criamos um grande plano e colocamos para funcionar. No começo, tínhamos algumas poucas páginas, que eram controladas por um CMS. Não tinha muito código JavaScript porque nosso sistema entrega grande parte do conteúdo.</p>

<p>Eis uma versão grosseira de como era a estrutura do nosso projeto:</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img1.png"></figure>

<p>Colocamos o código que ficaria do lado do cliente em diretórios diferentes. O código do lado servidor era só em PHP, naquele momento, então, ele foi para no diretório<code>php</code>. Tudo envolvia cerca de 30 arquivos e estava tudo certo. </p>

<h2>A Jornada</h2>

<p>Por alguns meses, tentamos alguns conceitos e mudamos os códigos do projeto várias vezes. Do que temos agora, poderia apontar quatro grande problemas pelos quais passamos.</p>

<h3>Problema #1 - Inúmeros Arquivos Mal Estruturados</h3>

<p>Parece que o cliente estava feliz com o resultado e decidiu investir um pouco mais em sua presença na Internet. Pediram para criarmos alguns novos recursos. Alguns eram somente novos lugares para conteúdo, outros eram adições a páginas existentes. Nós começamos a adicionar mais e mais arquivos em todos os diretórios listados mais acima. Isso começou a ficar um pouco bagunçado, então, decidimos criar subdiretórios para as diferentes páginas e salvar o código necessário por lá.</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img2.png"></figure>

<p>Por exemplo, as folhas de estilo CSS para a página <em>about</em> estavam em <code>css/about/styles.css</code>. O JavaScript estava em <code>js/about/scripts.js</code> e por aí vai. Nós usamos um script PHP que concatena os arquivos. Houve, claro, partes do site que estavam em diversas páginas. Elas colocamos no diretório <code>common</code>. Isso saiu bem por um tempo, mas não funcionou por muito tempo quando os diretórios ficaram cheios, demorava muito modificar algo. Você teria de pesquisar em três diretórios diferentes para encontrar algo que era preciso. O site ainda era escrito, principalmente, em PHP.</p>

<h3>Problema #2 - A Reviravolta ou Como Nós Bagunçamos Tudo</h3>

<p>Por esses dias, aplicações móveis ficaram popular. O cliente queria que seu site também estivesse disponível para dispositivos móveis e esse é a grande reviravolta do projeto. Tivemos de converter o site para uma aplicação de página única. E não foi só isso, era preciso várias e várias funcionalidades de tempo real. Claro, nem todo o conteúdo do site tinha de ser carregado dinâmicamente. SEO ainda era uma parte importante na visão do cliente. Nós escolhemos o <a href="http://www.mean.io/">conjunto MEAN</a> para as partes futuras. O problema estava na páginas antigas. O conteúdo delas tinha de ser servido pelo PHP, mas a lógica mudou completamente ao ponto de ser, completamente, em JavaScript. Por semanas, sentimo-nos como os passageiros do Titanic. Estávamos aperreados para lançar algo, mas encontrávamos buraco atrás de buraco e, logo o nosso navio estaria cheio de água (defeitos/bugs).  </p>

<h3>Problema #3 - Um Árduo Processo de Trabalho</h3>

<p>Nós usamos o <a href="http://gruntjs.com/">GruntJS</a> por um tempo, mas migramos para o <a href="http://gulpjs.com/">Gulp</a>. Isso ajudou bastante, porque aumentou nossa velocidade de desenvolvimento. Porém, ainda era estranho demais para adicionar ou editar componentes existentes. A arquitetura sólida que tínhamos no começo, transformou-se em uma mistura complexa de arquivos. Sim, havia conveções estritas de nomeação e localização dos arquivos, mas ainda assim era bagunçado. Por fim, colocamos nossos cérebros para funcionar e chegamos ao seguinte formato:</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img3.png"></figure>

<p>Nós dividimos o site em componentes diferentes, que eram quase como caixas pretas. Eles viviam em seus próprios diretórios. Tudo relacionado ao componente era salvo dentro do diretório do componente. Nós projetamos, cuidadosamente, as APIs das classes. Elas eram testáveis e comunicativas. Percebemos que esse tipo de arquitetura funcionava melhor para nós, uma vez que tínhamos inúmeros módulos independentes. Sim, estávamos misturando nossos arquivos JavaScript com os estilos CSS e modelos HTML, mas era mais fácil trabalhar em relação ao módulo que ter de navegar por vários níveis de diversos diretórios.</p>

<h3>Problema #4  - Angular vs. Código Customizado</h3>

<p>As páginas que eram velhas tínhamos de entregar através do PHP, também estavam repletas de código JavaScript. Contudo, em alguns casos, o Angular.js não lidava muito bem com isso. Tivemos de criar alguns <em>hacks</em> para fazer as coisas funcionarem perfeitamente. Nós acabamos em uma mistura de controladores do Angular e códigos customizados. A boa notícia era que o orçamento do projeto tinha aumentado e pudemos usar nossa própria biblioteca. Dessa vez, eu estava desenvolvendo meu próprio <a href="http://code.tutsplus.com/tutorials/absurdjs-or-why-i-wrote-my-own-css-preprocessor--net-36003">pré-processador CSS</a>. O projeto correu muito, muito rápido. Em pouco tempo, pude portar minha biblioteca de forma que pudesse ser usada no lado do cliente. Ela se transformou em uma pequena biblioteca, linha por linha, que, então, começamos a integrar no projeto.</p>

<h4>Por Que Criar Uma Nova Biblioteca?</h4>

<p>Você deve estar se perguntando isso. Bem, existem diversas outras bibliotecas que proveem uma vasta gama de capacidades. Sim, isso é verdade, mas... não precisávamos de uma vasta gama de funcionalidades. Precisávamos de coisas específicas e nada mais. Nós já tínhamos aceitado adicionar alguns kilobytes a mais, para pode adicionar uma biblioteca popular. Esse não era o grande problema</p><p>A situação da nossa base de códigos que era o problema. Estávamos focados em construir uma boa arquitetura e todos concordávamos que, algumas vez, uma solução customizadas servia melhor. O uso da Angular, Ember, Knockout ou Backbone vem com seus benefícios, mas, a verdade é que não há uma biblioteca universal.</p><p>Gosto do que o <a href="http://adactio.com/">Jeremy Keith</a> disse em sua palestra <a href="http://krasimirtsonev.com/blog/article/The-Power-Of-Simplicity-by-Jeremy-Keith">O poder da simplicidade</a>, que o mais importante ao escolher sua ferramenta é a filosofia da pessoa que criou a ferramenta e se essa filosofia alinha com a sua. Se as ideias da biblioteca não alinha com as suas, logo-logo, você encontrará problemas. A mesma coisa aconteceu conosco. Tentamos usar a Angular e encontramos muitas dificuldades. Éramos capazes de resolver os problemas, mas tínhamos de usar de <em>hacks</em> e soluções alternativas complexas</p><p>Também tentamos a Ember, mas também não funcionou, principalmente por ela se basear, fortemente, em seu mecanismo de roteamento. A Backbone foi uma escolha interessante e o mais próximo da nossa visão. Entretanto, quando apresentei a <a href="http://absurdjs.com/">AbsurdJS</a> decidimos utilizá-la.</p>

<h2>O Que A AbsurdJS Fez Por Nós</h2>

<p><a href="http://absurdjs.com/">AbsurdJS</a> começou como um <a href="http://absurdjs.com/pages/css-preprocessing/">pré-processador CSS</a>, expandiu-se em um <a href="http://absurdjs.com/pages/html-preprocessing/">pré-processador HTML</a> e foi portado, com sucesso, para uso no lado do cliente. Assim, no começo, usamos ele para compilar JavaScript em HTML ou CSS. Sim, você leu direito: começamos criando nossas folhas de estilo e código HTML, em JavaScript (provavelmente, isso soa estranho, mas, por favor, continue lendo). continuei desenvolvendo a biblioteca e várias outras funcionalidades foram adicionadas.</p>

<h3>Dividir e Conquistar</h3>

<p>Quando se tem um sistema complexo, com muitas páginas, você não quer resolver problemas grandes. É muito melhor dividir em vários problemas menores e solucioná-los um a um. Decidimos que nossa aplicaçao seria construída a partir de componentes menores, mais ou menos assim:</p>

<pre class="brush: javascript">var absurd = Absurd();
var MyComp = absurd.component('MyComp', {
    constructor: function() {
        // ...
    }
});
var instance = MyComp();
</pre>

<p><code>absurd.component</code> define uma classe. Invocando o método <code>MyComp()</code> cria-se uma nova instância.</p>

<h3>Vamos Bater Um Papo</h3>

<p>Era preciso um canal de comunicação para todos esses pequenos componentes. O padrão de projeto Observador (Observer Pattern) era perfeito para esse caso. Assim, cada componente é um despachador de eventos.</p>

<pre class="brush: javascript">var MyComp = absurd.component('MyComp', {
    doSomething: function() {
        this.dispatch('something-happen');
    }
});
var instance = MyComp();
instance.on('something-happen', function() {
    console.log('Hello!');
});
instance.doSomething();
</pre>

<p>Também somos capazes de passar dados junto das mensagens. A definição de componentes e sua natureza "ouvinte-despachante" é bem trivial. Resolvi adotar esse conceito baseado nas bibliotecas mais populares, além de parecer natural. Isso também facilitou o uso da AbsurdJS por parte dos meus colegas de trabalho.</p>

<h3>Controlando a DOM</h3>

<p>Além do código HTML servido pelo PHP, tínhamos elementos DOM criados dinamicamente. Isso significa que precisávamos de acesso aos elementos DOM existentes ou aos novos, que seriam adicionados à página. Por exemplo, digamos que temos o HTML a seguir:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;Page title&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
&lt;/div&gt;</pre>

<p>Eis um componentes que retorna o título da página:</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: '.content h1',
    constructor: function() {
        this.populate();
        console.log(this.el.innerHTML); // Título da página
    }
})();
</pre>

<p>O método <code>populate</code> é o único método <em>mágico</em> em todaa biblioteca. Ele faz inúmeras coisas, como a compilação de HTML ou CSS, ligação de eventos e coisas do tipo. No exemplo acima, ele percebe que há uma propriedade <code>html</code> e inicializa a variável <code>el</code> que aponta para o elemento DOM. Isso funciona muito bem para nós, já que, uma vez que tivermos aquela referência, nós seremos capazes de trabalhar com aqueles elementos e seus filhos. Para aqueles componentes que precisassem de elementos criados dinâmicamente, a propriedade <code>html</code> aceita um objeto.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: {
        'div.content': {
            h1: 'Page title',
            p: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
        }
    },
    constructor: function() {
        this.populate();
        document.querySelector('body').appendChild(this.el);
    }
})();
</pre>

<p>The JSON above is translated to the same HTML markup. I chose JSON because from a JavaScript point of view, it is much more flexible. We are able to merge objects, replace or delete only parts of it. In most of the popular frameworks, the templates are just plain text that makes them difficult for manipulating. AbsurdJS also has its own <a href="http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line">templating engine</a>.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: {
        'div.content': {
            h1: '&lt;% this.title %&gt;',
            ul: [
                '&lt;% for(var i=0; i',
                { li: '&lt;% this.availableFor[i] %&gt;' },
                '&lt;% } %&gt;'
            ]
        }
    },
    title: 'That\'s awesome',
    availableFor: ['all browsers', 'Node.js'],
    constructor: function() {
        this.populate();
        document.querySelector('body').appendChild(this.el);
    }
})();
</pre>

<p>The result is:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;That's awesome&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;all browsers&lt;/li&gt;
        &lt;li&gt;Node.js&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>The <code>this</code> keyword in the expressions above, points to the component itself. The code between <code>&lt;%</code> and <code>%&gt;</code> is valid JavaScript. So, features like computed properties could be easily developed directly into the template's definition. Of course, we are able to use the same template engine with already existing markup. For example:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;&lt;% this.title %&gt;&lt;/h1&gt;
    &lt;ul&gt;
        &lt;% for(var i=0; i&amp;amp;lt;this.availableFor.length; i++) { %&gt;
        &lt;li&gt;&lt;% this.availableFor[i] %&gt;&lt;/li&gt;
        &lt;% } %&gt;
    &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>... could be controlled with the following component (the result is the same):</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: '.content',
    title: 'That\'s awesome',
    availableFor: ['all browsers', 'Node.js'],
    constructor: function() {
        this.populate();
    }
})();
</pre>

<p>Anyway, the point is that we were able to define templates or create such from scratch. We are also able to control the data that is injected in an easy and natural way. Everything is just properties of the good old JavaScript object. </p>

<h3>What About the Styling?</h3>

<p>We successfully split the whole system in to small modules. The parts that were before Angular controllers, became AbsurdJS components. We realized that their HTML was tightly attached to their definition, that completely changed the management of the markup in the application. We stopped thinking about the concatenation, conventions or anything like that. We did not have to create HTML files at all. When I look back, I could see this exact moment in our commit history. It is easily visible because many files were removed from the code-base. </p>

<p>Then I thought, what will happen if we do the same thing with the CSS. It was of course possible because AbsurdJS was a CSS preprocessor and could produce CSS. We just got the compiled string, create a new <code>style</code> tag in the <code>head</code> of the current page and inject it there.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    css: {
        '.content': {
            h1: {
                color: '#99FF00',
                padding: 0,
                margin: 0
            },
            p: {
                fontSize: '20px'
            }
        }
    },
    html: '.content',
    constructor: function() {
        this.populate();
    }
})();
</pre>

<p>Here is the <code>style</code> tag which is produced:</p>

<pre class="brush: html">&lt;style id="MyComp-css" type="text/css"&gt;
    .content h1 {
      color: #99FF00;
      padding: 0;
      margin: 0;
    }
    .content p {
      font-size: 20px;
    }
&lt;/style&gt;</pre>

<p>And day by day we transferred the CSS styles from the SASS files (because, at some point, we chose SASS as a CSS preprocessor) to the AbsurdJS components. To be honest, it was pretty easy because all the mixins and variables which we have, were defined as JavaScript functions and variables. The sharing of the styles was even easier because everything was JavasSript. </p>

<h3>That Awkward Moment</h3>

<p>... when everything works perfectly but you feel that something is wrong</p>

<p>We were looking at the code. It worked. AbsurdJS drove even the old parts. The new stuff uses the same library. The HTML and the CSS were nicely separated and placed directly into the components' definition. However, I felt that there was something wrong. I stopped for a while and asked myself: "What is the Web made from?".</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img4.png"></figure>

<p>And what we did, is a little bit different. It looks more like the picture below.</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img5.png"></figure>

<p>I've been building websites for more than ten years and I remember the times when we all fought for the big separation of these three building materials. And what I did in this project is exactly the opposite. There was no CSS and HTML files (almost) at all. Everything was JavaScript.&nbsp;</p><p>Many people will say that this is ridiculous and we should give the client's money back. Yes, this could be true, but this concept worked perfectly in our case. We did not write an application. In fact, we wrote a bunch of independent components. I believe that the Web will be a combination of ready-to-use components.&nbsp;</p><p>We, as developers, will have to develop such components and probably connect with and use such components written by others. Projects like <a href="http://absurdjs.com/">AbsurdJS</a> or <a href="http://www.polymer-project.org/">Polymer</a> are showing that this is possible and I encourage you to experiment in this direction. </p>

<h2>Back to Reality</h2>

<p>So in the end the client's business went well. It was so good that he decided to launch a new service. And guess what. He wanted some parts of the existing application transferred into the new project. I can't tell you how happy we were to move components from one place to another. We did not have to setup something, copy HTML markup or CSS files. We just got the JavaScript file of the component, placed it somewhere and created an instance of it. It just worked because there were no dependencies. I'd not be surprised if some of these components are put up for sale very soon. They are pretty light and provide nice functionality connected with the client's product.</p>

<p>Yes, we broke some rules. Rules that I personally agree with. Rules that I followed for many years. However, the reality is that we all want quality and sometimes that quality is reachable by breaking the rules. We want to produce good, well structured code which is easily maintainable, flexible and extendable. We do not want to look back and say, "Oh my gosh ... was that written by me!?". When I look back now, I know why the code looks the way it does. It looks like that because it was written for that project specifically.</p>

<h2>Conclusion</h2>

<p>If you found this tutorial interesting, check out the official page of <a href="http://absurdjs.com/">AbsurdJS</a>. There are guides, documentation, and articles. You can even try the <a href="http://absurdjs.com/pages/try-it/">library online</a>. Like every other tool, AbsurdJS is designed for specific usage. It fit well for our project and may fit for yours. I don't even call it a framework, because I don't like this definition. It's more like a toolbox rather then a full stack framework. Feel free to experiment with it, make pull requests or submit issues. It's completely open source and <a href="https://github.com/krasimir/absurd">available at GitHub</a>.</p>