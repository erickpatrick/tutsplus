<h1>Componentizando a Web</h1>

<p>Essa é uma história sobre um dos meus projetos. Um bem grande. Uma mistura entre <a href="http://php.net/">PHP</a> e <a href="http://nodejs.org/">Node.js</a>. É uma aplicação de página única (SPA) por um lado, e um site otimizado para buscas (SEO) por outro. Milhares de JavaScipt, CSS e HTML escritos. Em uma única palavra, um pesadelo em forma de código <em>spaghetti</em> para qualquer desenvolvedor. Houve altos e baixos. Produzindo e solucionando problemas. Lutando com as mais novas tecnologias, acabamos com uma biblioteca simples e maravilhosa, que será o tópico desse artigo</p>

<h2>O Começo</h2>

<p>Como sempre acontece, o projeto não foi considerado grande. Recebemos o resumo do encontro com o cliente, discutimos sobre como o desenvolvimento seria levado, que tecnologias seria utilizadas e como as utilizaríamos. Criamos um grande plano e colocamos para funcionar. No começo, tínhamos algumas poucas páginas, que eram controladas por um CMS. Não tinha muito código JavaScript porque nosso sistema entrega grande parte do conteúdo.</p>

<p>Eis uma versão grosseira de como era a estrutura do nosso projeto:</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img1.png"></figure>

<p>Colocamos o código que ficaria do lado do cliente em diretórios diferentes. O código do lado servidor era só em PHP, naquele momento, então, ele foi para no diretório<code>php</code>. Tudo envolvia cerca de 30 arquivos e estava tudo certo. </p>

<h2>A Jornada</h2>

<p>Por alguns meses, tentamos alguns conceitos e mudamos os códigos do projeto várias vezes. Do que temos agora, poderia apontar quatro grande problemas pelos quais passamos.</p>

<h3>Problema #1 - Inúmeros Arquivos Mal Estruturados</h3>

<p>Parece que o cliente estava feliz com o resultado e decidiu investir um pouco mais em sua presença na Internet. Pediram para criarmos alguns novos recursos. Alguns eram somente novos lugares para conteúdo, outros eram adições a páginas existentes. Nós começamos a adicionar mais e mais arquivos em todos os diretórios listados mais acima. Isso começou a ficar um pouco bagunçado, então, decidimos criar subdiretórios para as diferentes páginas e salvar o código necessário por lá.</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img2.png"></figure>

<p>Por exemplo, as folhas de estilo CSS para a página <em>about</em> estavam em <code>css/about/styles.css</code>. O JavaScript estava em <code>js/about/scripts.js</code> e por aí vai. Nós usamos um script PHP que concatena os arquivos. Houve, claro, partes do site que estavam em diversas páginas. Elas colocamos no diretório <code>common</code>. Isso saiu bem por um tempo, mas não funcionou por muito tempo quando os diretórios ficaram cheios, demorava muito modificar algo. Você teria de pesquisar em três diretórios diferentes para encontrar algo que era preciso. O site ainda era escrito, principalmente, em PHP.</p>

<h3>Problema #2 - A Reviravolta ou Como Nós Bagunçamos Tudo</h3>

<p>Por esses dias, aplicações móveis ficaram popular. O cliente queria que seu site também estivesse disponível para dispositivos móveis e esse é a grande reviravolta do projeto. Tivemos de converter o site para uma aplicação de página única. E não foi só isso, era preciso várias e várias funcionalidades de tempo real. Claro, nem todo o conteúdo do site tinha de ser carregado dinâmicamente. SEO ainda era uma parte importante na visão do cliente. Nós escolhemos o <a href="http://www.mean.io/">conjunto MEAN</a> para as partes futuras. O problema estava na páginas antigas. O conteúdo delas tinha de ser servido pelo PHP, mas a lógica mudou completamente ao ponto de ser, completamente, em JavaScript. Por semanas, sentimo-nos como os passageiros do Titanic. Estávamos aperreados para lançar algo, mas encontrávamos buraco atrás de buraco e, logo o nosso navio estaria cheio de água (defeitos/bugs).  </p>

<h3>Problema #3 - Um Árduo Processo de Trabalho</h3>

<p>Nós usamos o <a href="http://gruntjs.com/">GruntJS</a> por um tempo, mas migramos para o <a href="http://gulpjs.com/">Gulp</a>. Isso ajudou bastante, porque aumentou nossa velocidade de desenvolvimento. Porém, ainda era estranho demais para adicionar ou editar componentes existentes. A arquitetura sólida que tínhamos no começo, transformou-se em uma mistura complexa de arquivos. Sim, havia conveções estritas de nomeação e localização dos arquivos, mas ainda assim era bagunçado. Por fim, colocamos nossos cérebros para funcionar e chegamos ao seguinte formato:</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img3.png"></figure>

<p>Nós dividimos o site em componentes diferentes, que eram quase como caixas pretas. Eles viviam em seus próprios diretórios. Tudo relacionado ao componente era salvo dentro do diretório do componente. Nós projetamos, cuidadosamente, as APIs das classes. Elas eram testáveis e comunicativas. Percebemos que esse tipo de arquitetura funcionava melhor para nós, uma vez que tínhamos inúmeros módulos independentes. Sim, estávamos misturando nossos arquivos JavaScript com os estilos CSS e modelos HTML, mas era mais fácil trabalhar em relação ao módulo que ter de navegar por vários níveis de diversos diretórios.</p>

<h3>Problema #4  - Angular vs. Código Customizado</h3>

<p>As páginas que eram velhas tínhamos de entregar através do PHP, também estavam repletas de código JavaScript. Contudo, em alguns casos, o Angular.js não lidava muito bem com isso. Tivemos de criar alguns <em>hacks</em> para fazer as coisas funcionarem perfeitamente. Nós acabamos em uma mistura de controladores do Angular e códigos customizados. A boa notícia era que o orçamento do projeto tinha aumentado e pudemos usar nossa própria biblioteca. Dessa vez, eu estava desenvolvendo meu próprio <a href="http://code.tutsplus.com/tutorials/absurdjs-or-why-i-wrote-my-own-css-preprocessor--net-36003">pré-processador CSS</a>. O projeto correu muito, muito rápido. Em pouco tempo, pude portar minha biblioteca de forma que pudesse ser usada no lado do cliente. Ela se transformou em uma pequena biblioteca, linha por linha, que, então, começamos a integrar no projeto.</p>

<h4>Por Que Criar Uma Nova Biblioteca?</h4>

<p>Você deve estar se perguntando isso. Bem, existem diversas outras bibliotecas que proveem uma vasta gama de capacidades. Sim, isso é verdade, mas... não precisávamos de uma vasta gama de funcionalidades. Precisávamos de coisas específicas e nada mais. Nós já tínhamos aceitado adicionar alguns kilobytes a mais, para pode adicionar uma biblioteca popular. Esse não era o grande problema</p><p>A situação da nossa base de códigos que era o problema. Estávamos focados em construir uma boa arquitetura e todos concordávamos que, algumas vez, uma solução customizadas servia melhor. O uso da Angular, Ember, Knockout ou Backbone vem com seus benefícios, mas, a verdade é que não há uma biblioteca universal.</p><p>Gosto do que o <a href="http://adactio.com/">Jeremy Keith</a> disse em sua palestra <a href="http://krasimirtsonev.com/blog/article/The-Power-Of-Simplicity-by-Jeremy-Keith">O poder da simplicidade</a>, que o mais importante ao escolher sua ferramenta é a filosofia da pessoa que criou a ferramenta e se essa filosofia alinha com a sua. Se as ideias da biblioteca não alinha com as suas, logo-logo, você encontrará problemas. A mesma coisa aconteceu conosco. Tentamos usar a Angular e encontramos muitas dificuldades. Éramos capazes de resolver os problemas, mas tínhamos de usar de <em>hacks</em> e soluções alternativas complexas</p><p>Também tentamos a Ember, mas também não funcionou, principalmente por ela se basear, fortemente, em seu mecanismo de roteamento. A Backbone foi uma escolha interessante e o mais próximo da nossa visão. Entretanto, quando apresentei a <a href="http://absurdjs.com/">AbsurdJS</a> decidimos utilizá-la.</p>

<h2>O Que A AbsurdJS Fez Por Nós</h2>

<p><a href="http://absurdjs.com/">AbsurdJS</a> começou como um <a href="http://absurdjs.com/pages/css-preprocessing/">pré-processador CSS</a>, expandiu-se em um <a href="http://absurdjs.com/pages/html-preprocessing/">pré-processador HTML</a> e foi portado, com sucesso, para uso no lado do cliente. Assim, no começo, usamos ele para compilar JavaScript em HTML ou CSS. Sim, você leu direito: começamos criando nossas folhas de estilo e código HTML, em JavaScript (provavelmente, isso soa estranho, mas, por favor, continue lendo). continuei desenvolvendo a biblioteca e várias outras funcionalidades foram adicionadas.</p>

<h3>Dividir e Conquistar</h3>

<p>Quando se tem um sistema complexo, com muitas páginas, você não quer resolver problemas grandes. É muito melhor dividir em vários problemas menores e solucioná-los um a um. Decidimos que nossa aplicaçao seria construída a partir de componentes menores, mais ou menos assim:</p>

<pre class="brush: javascript">var absurd = Absurd();
var MyComp = absurd.component('MyComp', {
    constructor: function() {
        // ...
    }
});
var instance = MyComp();
</pre>

<p><code>absurd.component</code> define uma classe. Invocando o método <code>MyComp()</code> cria-se uma nova instância.</p>

<h3>Vamos Bater Um Papo</h3>

<p>Era preciso um canal de comunicação para todos esses pequenos componentes. O padrão de projeto Observador (Observer Pattern) era perfeito para esse caso. Assim, cada componente é um despachador de eventos.</p>

<pre class="brush: javascript">var MyComp = absurd.component('MyComp', {
    doSomething: function() {
        this.dispatch('something-happen');
    }
});
var instance = MyComp();
instance.on('something-happen', function() {
    console.log('Hello!');
});
instance.doSomething();
</pre>

<p>Também somos capazes de passar dados junto das mensagens. A definição de componentes e sua natureza "ouvinte-despachante" é bem trivial. Resolvi adotar esse conceito baseado nas bibliotecas mais populares, além de parecer natural. Isso também facilitou o uso da AbsurdJS por parte dos meus colegas de trabalho.</p>

<h3>Controlando a DOM</h3>

<p>Além do código HTML servido pelo PHP, tínhamos elementos DOM criados dinamicamente. Isso significa que precisávamos de acesso aos elementos DOM existentes ou aos novos, que seriam adicionados à página. Por exemplo, digamos que temos o HTML a seguir:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;Page title&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
&lt;/div&gt;</pre>

<p>Eis um componentes que retorna o título da página:</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: '.content h1',
    constructor: function() {
        this.populate();
        console.log(this.el.innerHTML); // Título da página
    }
})();
</pre>

<p>O método <code>populate</code> é o único método <em>mágico</em> em todaa biblioteca. Ele faz inúmeras coisas, como a compilação de HTML ou CSS, ligação de eventos e coisas do tipo. No exemplo acima, ele percebe que há uma propriedade <code>html</code> e inicializa a variável <code>el</code> que aponta para o elemento DOM. Isso funciona muito bem para nós, já que, uma vez que tivermos aquela referência, nós seremos capazes de trabalhar com aqueles elementos e seus filhos. Para aqueles componentes que precisassem de elementos criados dinâmicamente, a propriedade <code>html</code> aceita um objeto.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: {
        'div.content': {
            h1: 'Page title',
            p: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
        }
    },
    constructor: function() {
        this.populate();
        document.querySelector('body').appendChild(this.el);
    }
})();
</pre>

<p>O JSON acima é convertido no mesmo código HTML. Escolhi o formato JSON porque, do ponto de vista do JavaScript, ele é muito mais flexível. Somos capazes de fundir objetos, substituir ou apagar só alguma parte deles. Nas bibliotecas mais populares, os modelos (templates) são em texto puro, o que dificulta a manipulação deles. AbsurdJS também tem seu próprio <a href="http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line">motor de modelagem</a> (templating engine).</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: {
        'div.content': {
            h1: '&lt;% this.title %&gt;',
            ul: [
                '&lt;% for(var i=0; i',
                { li: '&lt;% this.availableFor[i] %&gt;' },
                '&lt;% } %&gt;'
            ]
        }
    },
    title: 'Muito massa',
    availableFor: ['todos navegadores', 'Node.js'],
    constructor: function() {
        this.populate();
        document.querySelector('body').appendChild(this.el);
    }
})();
</pre>

<p>O resultado é:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;Muito massa&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;todos navegadoress&lt;/li&gt;
        &lt;li&gt;Node.js&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>A palavra chave <code>this</code> nas expressões acima, aponta para o próprio componente. O código entr <code>&lt;%</code> e <code>%&gt;</code>é JavaScript válido. Assim, recursos como propriedades computadas podem ser desenvolvidas diretamente na definição do modelo. Claro, somos capazes de usar o mesmo motor de modelagem com código HTMl já existente. Por exemplo:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;&lt;% this.title %&gt;&lt;/h1&gt;
    &lt;ul&gt;
        &lt;% for(var i=0; i&amp;amp;lt;this.availableFor.length; i++) { %&gt;
        &lt;li&gt;&lt;% this.availableFor[i] %&gt;&lt;/li&gt;
        &lt;% } %&gt;
    &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>... poderia ser controlado pelo componente a seguir (o resultado é o mesmo):</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: '.content',
    title: 'Muito massa',
    availableFor: ['todos navegadores', 'Node.js'],
    constructor: function() {
        this.populate();
    }
})();
</pre>

<p>De qualquer forma, o ponto é que fomos capazes de definir modelos ou criar novos modelos do zero. Também fomos capazes de controlar os dados que eram injetados de forma simples e natural. Tudo é uma propriedade do bom e velho objeto JavaScript. </p>

<h3>E Com Relação À Estilização?</h3>

<p>Nós dividimos o sistema inteiro, de forma bem sucedida, em vários módulos pequenos. As partes que, antes, eram controladores Angular, tornaram-se componentes do AbsurdJS. Percebemos que o HTML estava fortemente ligado às suas definições, o que mudava completamente a administração dos códigos HTML na aplicação. Paramos de pensar em concatenção, conveções e qualquer coisa dessas. Não tivemos de criar qualquer arquivo HTML. Quando penso naquele momento, consigo visualizar o exato momento em nosso histórico de <em>commits</em>. É facilmente visível porque muitos arquivos foram removidos da nossa base. </p>

<p>Então pensei, o que aconteceria se fizéssemos o mesmo com o CSS? Isso também foi possível, claro, porque a AbsurdJS também era um pré-processador CSS e podia produzir CSS. Só pegamos a cadeia de caracteres compilada, criamos uma nova tag <code>style</code> no <code>head</code> da página atual e o injetamos lá.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    css: {
        '.content': {
            h1: {
                color: '#99FF00',
                padding: 0,
                margin: 0
            },
            p: {
                fontSize: '20px'
            }
        }
    },
    html: '.content',
    constructor: function() {
        this.populate();
    }
})();
</pre>

<p>Eis a tag <code>style</code> gerada:</p>

<pre class="brush: html">&lt;style id="MyComp-css" type="text/css"&gt;
    .content h1 {
      color: #99FF00;
      padding: 0;
      margin: 0;
    }
    .content p {
      font-size: 20px;
    }
&lt;/style&gt;</pre>

<p>E, dia após dia, transferimos as folhas de estilo CSS dos arquivos SASS (porque, em um dado momento, optamos pelo SASS como nosso pré-processador CSS) para componentes AbsurdJS. Sendo honesto, foi muito fácil porque todas as <em>mixins</em> e variáveis que tínhamos, eram funções e variáveis JavaScript. O compartilhamento de estilos foi ainda mais tudo era JavaScript. </p>

<h3>Aquele Momento Estranho</h3>

<p>... quando tudo funciona perfeitamente mas você sente que algo está errado.</p>

<p>Estávamos olhando o código. Ele funcionava. A AbsurdJS colocou rédeas até nas partes antigas. O novo e o antigo usam a mesma biblioteca. O HTML e o CSS estavam bem separados e posicionados como definições de componentes. Entretanto, sentia que algo estava faltando. Parei por um tempo e perguntei para mim mesmo: "Do que a Web é feita?".</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img4.png"></figure>

<p>And what we did, is a little bit different. It looks more like the picture below.</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img5.png"></figure>

<p>I've been building websites for more than ten years and I remember the times when we all fought for the big separation of these three building materials. And what I did in this project is exactly the opposite. There was no CSS and HTML files (almost) at all. Everything was JavaScript.&nbsp;</p><p>Many people will say that this is ridiculous and we should give the client's money back. Yes, this could be true, but this concept worked perfectly in our case. We did not write an application. In fact, we wrote a bunch of independent components. I believe that the Web will be a combination of ready-to-use components.&nbsp;</p><p>We, as developers, will have to develop such components and probably connect with and use such components written by others. Projects like <a href="http://absurdjs.com/">AbsurdJS</a> or <a href="http://www.polymer-project.org/">Polymer</a> are showing that this is possible and I encourage you to experiment in this direction. </p>

<h2>Back to Reality</h2>

<p>So in the end the client's business went well. It was so good that he decided to launch a new service. And guess what. He wanted some parts of the existing application transferred into the new project. I can't tell you how happy we were to move components from one place to another. We did not have to setup something, copy HTML markup or CSS files. We just got the JavaScript file of the component, placed it somewhere and created an instance of it. It just worked because there were no dependencies. I'd not be surprised if some of these components are put up for sale very soon. They are pretty light and provide nice functionality connected with the client's product.</p>

<p>Yes, we broke some rules. Rules that I personally agree with. Rules that I followed for many years. However, the reality is that we all want quality and sometimes that quality is reachable by breaking the rules. We want to produce good, well structured code which is easily maintainable, flexible and extendable. We do not want to look back and say, "Oh my gosh ... was that written by me!?". When I look back now, I know why the code looks the way it does. It looks like that because it was written for that project specifically.</p>

<h2>Conclusion</h2>

<p>If you found this tutorial interesting, check out the official page of <a href="http://absurdjs.com/">AbsurdJS</a>. There are guides, documentation, and articles. You can even try the <a href="http://absurdjs.com/pages/try-it/">library online</a>. Like every other tool, AbsurdJS is designed for specific usage. It fit well for our project and may fit for yours. I don't even call it a framework, because I don't like this definition. It's more like a toolbox rather then a full stack framework. Feel free to experiment with it, make pull requests or submit issues. It's completely open source and <a href="https://github.com/krasimir/absurd">available at GitHub</a>.</p>