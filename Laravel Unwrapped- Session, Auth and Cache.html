<h1>Desconstruindo Laravel: Session, Auth e Cache</h1>

<p>Nos últimos anos, <a href="http://laravel.com/" target="_self">Laravel</a> tornou-se uma das frameworks mais importantes e utilizadas por engenheiros de software na hora de construir suas aplicações web. Com popularidade semelhante à do <a href="http://ellislab.com/codeigniter" target="_self">CodeIgniter</a> em seus dias de glória, Laravel tem sido louvado pela sua simplicidade, facilidade de uso por parte dos iniciantes e aderência aos padrões da indústria.</p>

<h2>Introdução</h2>

<p>Algo que muitos programadores deixam de aproveitar do Laravel é a sua componentização. Desde sua conversão à utilização de componentes que lançam mão do composer, Laravel 4 tornou-se um sistema bastante modular, semelhante à verbosidade de frameworks mais maduras, como a Symfony. Ela usa o grupo de componentes chamado de <code class="inline">Illuminate</code>, que, na minha opinião, não é a framework em si, mas uma compilação de bibliotecas que uma framework pode chegar a usar. A framework Laravel, de verdade, é representada pela aplicação base do Laravel (encontrada no <a href="https://github.com/laravel/laravel" target="_self">repositório do GitHub</a> chamado <code>laravel/laravel</code>), que faz uso desses componente para construir uma aplicação web.</p>

<p>Nesse tutorial, nós nos aprofundaremos em alguns dos componentes desse grupo, aprendendo como eles funcionam, como eles são utilizados pela framework e como estender a funcionalidade deles.</p>

<h2>O Componente Session</h2>

<p>O componente Session do Laravel lida com as sessões das aplicações web. Ela faz uso de um sistema de drivers chamado Laravel Manager, que age tanto como uma fábrica como um envólucro para qualquer driver atribuído no arquivo de configuração. Até o momento da escrita desse post, o componente Session tem os seguintes drivers:</p>

<ul><li><code class="inline">file </code>- driver baseado em arquivo, onde os dados da sessão são salvos em um arquivo criptografado.</li>
<li><code class="inline">cookie </code>- driver baseados em cookies, onde os dados da sessão são salvos de forma criptografada nos cookies (do navegador) do usuário.</li>
<li><code class="inline">database </code>- os dados da sessão são salvos na base de dados configurada para a aplicação.</li>
<li><code class="inline">apc </code>- os dados da sessão são salvos no APC (Alternative PHP Cache).</li>
<li><code class="inline">memcached </code>- os dados da sessão são salvas no Memcached.</li>
<li><code class="inline">redis </code>- os dados da sessão são salvo no Redis.</li>
<li><code class="inline">array </code>- os dados da sessão são salvos em uma array do PHP. Atente que o driver de sessão baseado em array não dá suporte a persistência de dados e, geralmente, é usado somente em linha de comando.</li>
</ul><h3>Provedores de Serviço</h3>

<p>A maioria dos usuários de Laravel não percebem mas, grande parte de como o Laravel funciona se deve aos seus provedores de serviço. Os provedores de serviços são, em essência, arquivos inicializadores de cada componente e eles são tão abstraídos que os usuários podem utilizá-los para inicializar qualquer componente, de qualquer forma.</p>

<p>Uma explicação grosseira de como isso funciona segue abaixo::</p>

<ol><li>O componente Application do Laravel é inicializado. Esse é o driver principal de toda a framework, responsável por lidar com as Requisições HTTP, executar os provedores de serviços, e agir como recipiente de dependências para a framework.</li>
<li>Uma ver que um provedor de serviço é executado, o método <code>register</code> dele é chamado. Isso permite instanciar qualquer componente que quisermos.

<ul><li>Tenha em mente que todos os provedores de serviço tem acesso à aplicação principal do Laravel (via <code>$this-&gt;app</code>), o que permite que os provedores de serviços tenham acesso a instâncias de classes criadas de dentro do recipiente de depedência.</li></ul></li>
<li>Uma vez que essas dependências são carregadas, nós estamos livres para chamá-las ao chamar o recipiente, por exemplo, pelo sistema Facade do Laravel, através do <code>App::make</code>.</li>
</ol><p>Voltando ao componente Sessions, daremos uma rápida olhada no <code class="inline">SessionServiceProivider</code>:</p>

<pre class="brush: php"> /**
   * Register the session manager instance.
*
* @return void
*/
	protected function registerSessionManager()
	{
$this-&gt;app-&gt;bindShared('session', function($app)
{
	return new SessionManager($app);
});
	}

	/**
* Register the session driver instance.
*
* @return void
*/
	protected function registerSessionDriver()
	{
$this-&gt;app-&gt;bindShared('session.store', function($app)
{
	// First, we will create the session manager which is responsible for the
	// creation of the various session drivers when they are needed by the
	// application instance, and will resolve them on a lazy load basis.
	$manager = $app['session'];

	return $manager-&gt;driver();
});
	}</pre>

<p>Esses dois métodos são chamados pela função <code>register()</code>. O primeiro, <code>registerSessionManager()</code>, é chamado para registrar inicialmente o <code>SessionManager</code>. Essa classe estende a classe <code>Manager</code> que mencionei mais acima. O segundo, <code>registerSessionDriver()</code>, registrar um manipulador de registros para o manager, baseado nas configurações que instituimos no início. Isso, eventualmente, invoca esse método da classe <code>Illuminate\Support\Manager</code>:</p>

<pre class="brush: php">/**
   * Create a new driver instance.
*
* @param  string  $driver
* @return mixed
*
* @throws \InvalidArgumentException
*/
	protected function createDriver($driver)
	{
$method = 'create'.ucfirst($driver).'Driver';

// We'll check to see if a creator method exists for the given driver. If not we
// will check for a custom driver creator, which allows developers to create
// drivers using their own customized driver creator Closure to create it.
if (isset($this-&gt;customCreators[$driver]))
{
	return $this-&gt;callCustomCreator($driver);
}
elseif (method_exists($this, $method))
{
	return $this-&gt;$method();
}

throw new \InvalidArgumentException("Driver [$driver] not supported.");
	}</pre>

<p>Aqui, podemos ver que, baseado no nome do driver, escolhido no arquivo de configuração, um método específico é chamado. Então, se tivermos configurados o sistema para usar o manipulador de sessão do tipo <code>file</code>, ele invocará esse método na classe <code>SessionManager</code>:</p>

<pre class="brush: php">/**
   * Create an instance of the file session driver.
*
* @return \Illuminate\Session\Store
*/
	protected function createFileDriver()
	{
return $this-&gt;createNativeDriver();
	}

	/**
* Create an instance of the file session driver.
*
* @return \Illuminate\Session\Store
*/
	protected function createNativeDriver()
	{
$path = $this-&gt;app['config']['session.files'];

return $this-&gt;buildSession(new FileSessionHandler($this-&gt;app['files'], $path));
	}</pre>

<p>A classe correta do driver é, então, injetada na classe <code>Store</code>, que é responsável por invocar os métodos verdadeiros para manipulação da sessão. Isso permite que separemos a implementação da classe <code>SessionHandlerInterface</code> da SPL (Standard PHP Library), a classe <code>Store</code> facilita isso.</p>

<h3>Criando Nossa Própria Manipuladora de Sessão</h3>

<p>Vamos criar nossa própria classe manipuladora de sessão, usando MongoDB. Primeiro, precisaremos criar a classe <code>MongoSessionHandler</code> em uma instalação recém criada do Laravel (Nós pegaremos muitos códigos emprestados da classe<code>Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler</code>):</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Session;

  use Mongo;
  use MongoDate;
  use MongoBinData;

  class MongoSessionHandler implements \SessionHandlerInterface
  {
      /**
       * Configuração do Mongo DB
       *
       * @var array
       */
      protected $config;

      /**
       * Conexão do Mongo DB
       * 
       * @var \Mongo
       */
      protected $connection;

      /**
       * Coleção do Mongo DB
       * 
       * @var \MongoCollection
       */
      protected $collection;
      /**
       * Cria uma nova instância do Manipulador do driver do Mongo DB.
       *
       * @param  array $config
       *  - $config['host']       Mongodb host
       *  - $config['username']   Mongodb username
       *  - $config['password']   Mongodb password
       *  - $config['database']     Mongodb database
       *  - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * {@inheritDoc}
       */
      public function open($savePath, $sessionName)
      {
          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function close()
      {
          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function read($sessionId)
      {
          $session_data = $this-&gt;collection-&gt;findOne(array(
              '_id' =&gt; $sessionId,
          ));

          if (is_null($session_data)) {
              return '';
          } else {
              return $session_data['session_data']-&gt;bin;
          }
      }

      /**
       * {@inheritDoc}
       */
      public function write($sessionId, $data)
      {
          $this-&gt;collection-&gt;update(
              array(
                  '_id' =&gt; $sessionId
              ),
              array(
                  '$set' =&gt; array(
                      'session_data' =&gt; new MongoBinData($data, MongoBinData::BYTE_ARRAY),
                      'timestamp' =&gt; new MongoDate(),
                  )
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * {@inheritDoc}
       */
      public function destroy($sessionId)
      {
          $this-&gt;collection-&gt;remove(array(
              '_id' =&gt; $sessionId
          ));

          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function gc($lifetime)
      {
          $time = new MongoDate(time() - $lifetime);

          $this-&gt;collection-&gt;remove(array(
              'timestamp' =&gt; array('$lt' =&gt; $time),
          ));

          return true;
      }
  }
</pre>

<p>Você deve salvar esse arquivo no diretório <code>vendor/laravel/framework/src/Illuminate/Session</code>. Para os propósitos desse projeto, nós colocaremos nesse diretório, porém, idealmente, ele deve ficar localizado dentro de um diretório usando seu próprio namespace. </p>

<p>Feito isso, precisamos garantir que a classe <code>Manager</code> pode invocar o driver. Nós podemos fazer isso utilizando o método <code>Manager::extend</code>. Abra o arquivo <code>vendor/laravel/framework/src/Illuminate/Session/SessionServiceProvider.php</code> e adicione o código a seguir. Idealmente, deveríamos estender o provedor de serviços, porém, essa parte está além do escopo desse tutorial.</p>

<pre class="brush: php">/**
   * Prepara a callback do Mongo Driver
*
* @return  void
*/
	public function setupMongoDriver()
	{
$manager = $this-&gt;app['session'];

$manager-&gt;extend('mongo', function($app) {
    return new MongoSessionHandler(array(
        'host'       =&gt; $app['config']-&gt;get('session.mongo.host'),
        'username'   =&gt; $app['config']-&gt;get('session.mongo.username'),
        'password'   =&gt; $app['config']-&gt;get('session.mongo.password'),
        'database'   =&gt; $app['config']-&gt;get('session.mongo.database'),
        'collection' =&gt; $app['config']-&gt;get('session.mongo.collection')
    ));
});
	}</pre>

<p>Atualize o método <code>register()</code> para que ele invoce esse método:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;setupDefaultDriver();

$this-&gt;registerSessionManager();

$this-&gt;setupMongoDriver();

$this-&gt;registerSessionDriver();
	}</pre>

<p>Depois disso, precisamos definir a configuração do Mongo DB. Abra o arquivo <code>app/config/session.php</code> e definas as seguintes configurações:</p>

<pre class="brush: php">/**
   * Configurações do Mongo DB
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_session_collection'
	)</pre>

<p>Já que estamos nesse arquivo, também devemos atualizar a configuração do driver na parte superior <code class="inline">driver </code>:</p>

<pre class="brush: php">'driver' =&gt; 'mongo'</pre>

<p>Agora, tente acessar a página inicial (geralmente, <code>localhost/diretorio_instalacao_laravel/public</code>). Se a página carregar sem mostrar a página <code class="inline">WHOOPS</code> (página de erros), então, parabéns, nós fomos bem sucedidos em criar um driver de sessão novinho em folha! Teste-o, adicionando alguns dados fictícios na sessão, através do método <code>Session::set()</code> e, então, recupere-o através do <code>Session::get()</code> para mostrá-lo na página.</p>

<h2>The Auth Component</h2>

<p>The Laravel Auth component handles user authentication for the framework, as well as password management. What the Laravel component has done here is to create an abstract interpretation of the typical user-management system which is usable in most web applications, which in turn helps the programmer easily implement a login system. Like the Session component, it also makes use of the Laravel Manager. Currently, the Auth component has drivers for:</p>

<ul><li><code class="inline">eloquent</code> - this makes use of Laravel's built-in ORM called <code class="inline">Eloquent</code>. It also utilizes the pre-made <code>User.php</code> class inside the <code>models</code> folder.</li>
<li><code class="inline">database</code> - this uses whichever database connection is configured by default. It makes use of a <code>GenericUser</code> class for accessing the user data.</li>
</ul><p>Since this follows the same implementation as the <code>Session</code> component, the service provider is very similar to what we've seen on top:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('auth', function($app)
{
	// Once the authentication service has actually been requested by the developer
	// we will set a variable in the application indicating such. This helps us
	// know that we need to set any queued cookies in the after event later.
	$app['auth.loaded'] = true;

	return new AuthManager($app);
});
	}</pre>

<p>Here, we can see that it basically creates an <code>AuthManager</code> class that wraps around whichever driver we're using, as well as acting as a factory for it. Inside the <code>AuthManager</code>, it again creates the appropriate driver, wrapped around a <code>Guard</code> class, which acts the same way as the <code>Store</code> class from <code>Session</code>.</p>

<h3>Creating Our Own Auth Handler</h3>

<p>Like before, let's start by creating a <code>MongoUserProvider</code>:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Auth;

  use Mongo;
  use Illuminate\Hashing\HasherInterface;

  class MongoUserProvider implements UserProviderInterface {

      /**
       * The mongo instance
       *
       * @param  \Mongo
       */
      protected $connection;

      /**
       * The mongo connection instance
       *
       * @param  \MongoConnection
       */
      protected $collection;

      /**
       * The Mongo config array
       *
       * @var array
       */
      protected $config;

      /**
       * Create a new Mongo user provider.
       *
       * @param  array $config
       *     - $config['host']       Mongodb host
       *     - $config['username']   Mongodb username
       *     - $config['password']   Mongodb password
       *     - $config['database']   Mongodb database
       *     - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * Retrieve a user by their unique identifier.
       *
       * @param  mixed  $identifier
       * @return \Illuminate\Auth\UserInterface|null
       */
      public function retrieveById($identifier)
      {
          $user_data = $this-&gt;collection-&gt;findOne(array(
              '_id' =&gt; $identifier,
          ));

          if (!is_null($user_data)) {
              return new GenericUser((array) $user_data);
          }
      }

      /**
       * Retrieve a user by the given credentials.
       *
       * @param  array  $credentials
       * @return \Illuminate\Auth\UserInterface|null
       */
      public function retrieveByCredentials(array $credentials)
      {
          // Attempt to look for the user first regardless of password
          // We'll do that in the validateCredentials method
          if (isset($credentials['password'])) {
              unset($credentials['password']);
          }

          $user_data = $this-&gt;collection-&gt;findOne($credentials);

          if (!is_null($user_data)) {
              return new GenericUser((array) $user_data);
          }
      }

      /**
       * Validate a user against the given credentials.
       *
       * @param  \Illuminate\Auth\UserInterface  $user
       * @param  array  $credentials
       * @return bool
       */
      public function validateCredentials(UserInterface $user, array $credentials)
      {
          if (!isset($credentials['password'])) {
              return false;
          }
          
          return ($credentials['password'] === $user-&gt;getAuthPassword());
      }
  }</pre>

<p>It's important to take note here that I'm not checking against a hashed password, this was done for simplicity's sake to make it easier on our part to create dummy data and test this later. In production code, you need to make sure to hash the password. Check out the <code>Illuminate\Auth\DatabaseUserProvider</code> class for a great example on how to do this.</p>

<p>Afterwards, we need to register our custom driver callback on the <code>AuthManager</code>. To do so, we need to update the service provider's <code class="inline">register</code> method:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('auth', function($app)
{
	// Once the authentication service has actually been requested by the developer
	// we will set a variable in the application indicating such. This helps us
	// know that we need to set any queued cookies in the after event later.
	$app['auth.loaded'] = true;

	$auth_manager = new AuthManager($app);

	$auth_manager-&gt;extend('mongo', function($app) {
		return new MongoUserProvider(
			array(
				'host'       =&gt; $app['config']-&gt;get('auth.mongo.host'),
		        'username'   =&gt; $app['config']-&gt;get('auth.mongo.username'),
		        'password'   =&gt; $app['config']-&gt;get('auth.mongo.password'),
		        'database'   =&gt; $app['config']-&gt;get('auth.mongo.database'),
		        'collection' =&gt; $app['config']-&gt;get('auth.mongo.collection')
			)
		);
	});

	return $auth_manager;
});
	}</pre>

<p>Lastly, we also need to update the <code>auth.php</code> configuration file to make use of the Mongo driver, as well as provide it the proper Mongo configuration values:</p>

<pre class="brush: php">'driver' =&gt; 'mongo',
  ...
  ...
  ...
  /**
   * Mongo DB settings
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_auth_collection'
	)</pre>

<p>Testing this is a little trickier, to do so, use the Mongo DB CLI to insert a new user into the collection:</p>

<pre class="brush: bash">mongo

  &gt; use laravel_auth
  switched to db laravel_auth
  &gt; db.laravel_auth_collection.insert({id: 1, email:"nikko@nikkobautista.com", password:"test_password"})
  &gt; db.laravel_auth_collection.find()
  &gt; { "_id" : ObjectId("530c609f2caac8c3a8e4814f"), "id" 1, "email" : "nikko@emailtest.com", "password" : "test_password" }</pre>

<p>Now, test it out by trying an <code>Auth::validate</code> method call:</p>

<pre class="brush: php">var_dump(Auth::validate(array('email' =&gt; 'nikko@emailtest.com', 'password' =&gt; 'test_password')));</pre>

<p>This should dump a <code>bool(true)</code>. If it does, then we've successfully created our own Auth driver!</p>

<h2>The Cache Component</h2>

<p>The Laravel Cache component handles caching mechanisms for use in the framework. Like both of the components that we've discussed, it also makes use of the Laravel Manager (Are you noticing a pattern?). The Cache component has drivers for:</p>

<ul><li><code class="inline">apc</code></li>
<li><code class="inline">memcached</code></li>
<li><code class="inline">redis</code></li>
<li><code class="inline">file</code> - a file-based cache. Data is saved into the <code>app/storage/cache</code> path.</li>
<li><code class="inline">database</code> - database-based cache. Data is saved into rows into the database. The database schema is described in the <a href="http://laravel.com/docs/cache" target="_self">Laravel Documentation</a>.</li>
<li><code class="inline">array</code> - data is "cached" in an array. Keep in mind that the <code>array</code> cache is not persistent and is cleared on every page load.</li>
</ul><p>Since this follows the same implementation as both components that we've discussed, you can safely assume that the service provider is fairly similar:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('cache', function($app)
{
	return new CacheManager($app);
});

$this-&gt;app-&gt;bindShared('cache.store', function($app)
{
	return $app['cache']-&gt;driver();
});

$this-&gt;app-&gt;bindShared('memcached.connector', function()
{
	return new MemcachedConnector;
});

$this-&gt;registerCommands();
	}</pre>

<p>The <code>register()</code> method here creates a <code>CacheManager</code>, that again acts as a wrapper and factory for the drivers. Within the manager, it wraps the driver around a <code>Repository</code> class, similar to the <code>Store</code> and <code>Guard</code> classes.</p>

<h3>Creating Our Own Cache Handler</h3>

<p>Create the <code>MongoStore</code>, which should extend the <code>Illuminate\Cache\StoreInterface</code>:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Cache;

  use Mongo;

  class MongoStore implements StoreInterface
  {
      /**
       * The mongo instance
       *
       * @param  \Mongo
       */
      protected $connection;

      /**
       * The mongo connection instance
       *
       * @param  \MongoConnection
       */
      protected $collection;

      /**
       * The Mongo config array
       *
       * @var array
       */
      protected $config;

      /**
       * Create a new Mongo cache store.
       *
       * @param  array $config
       *     - $config['host']       Mongodb host
       *     - $config['username']   Mongodb username
       *     - $config['password']   Mongodb password
       *     - $config['database']   Mongodb database
       *     - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * Retrieve an item from the cache by key.
       *
       * @param  string  $key
       * @return mixed
       */
      public function get($key)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              return null;
          }

          return unserialize($cache_data['cache_data']);
      }

      /**
       * Return the whole object instead of just the cache_data
       * 
       * @param  string  $key
       * @return array|null
       */
      protected function getObject($key)
      {
          $cache_data = $this-&gt;collection-&gt;findOne(array(
              'key' =&gt; $key,
          ));

          if (is_null($cache_data)) {
              return null;
          }

          if (isset($cache_data['expire']) &amp;&amp; time() &gt;= $cache_data['expire']) {
              $this-&gt;forget($key);
              return null;
          }

          return $cache_data;
      }

      /**
       * Store an item in the cache for a given number of minutes.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @param  int     $minutes
       * @return void
       */
      public function put($key, $value, $minutes)
      {
          $expiry = $this-&gt;expiration($minutes);

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; array(
                      'cache_data' =&gt; serialize($value),
                      'expiry' =&gt; $expiry,
                      'ttl' =&gt; ($minutes * 60)
                  )
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Increment the value of an item in the cache.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       *
       * @throws \LogicException
       */
      public function increment($key, $value = 1)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              $new_data = array(
                  'cache_data' =&gt; serialize($value),
                  'expiry' =&gt; $this-&gt;expiration(0),
                  'ttl' =&gt; $this-&gt;expiration(0)
              );
          } else {
              $new_data = array(
                  'cache_data' =&gt; serialize(unserialize($cache_data['cache_data']) + $value),
                  'expiry' =&gt; $this-&gt;expiration((int) ($cache_data['ttl']/60)),
                  'ttl' =&gt; $cache_data['ttl']
              );
          }

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; $new_data
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Decrement the value of an item in the cache.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       *
       * @throws \LogicException
       */
      public function decrement($key, $value = 1)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              $new_data = array(
                  'cache_data' =&gt; serialize((0 - $value)),
                  'expiry' =&gt; $this-&gt;expiration(0),
                  'ttl' =&gt; $this-&gt;expiration(0)
              );
          } else {
              $new_data = array(
                  'cache_data' =&gt; serialize(unserialize($cache_data['cache_data']) - $value),
                  'expiry' =&gt; $this-&gt;expiration((int) ($cache_data['ttl']/60)),
                  'ttl' =&gt; $cache_data['ttl']
              );
          }

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; $new_data
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Store an item in the cache indefinitely.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       */
      public function forever($key, $value)
      {
          return $this-&gt;put($key, $value, 0);
      }

      /**
       * Remove an item from the cache.
       *
       * @param  string  $key
       * @return void
       */
      public function forget($key)
      {
          $this-&gt;collection-&gt;remove(array(
              'key' =&gt; $key
          ));
      }

      /**
       * Remove all items from the cache.
       *
       * @return void
       */
      public function flush()
      {
          $this-&gt;collection-&gt;remove();
      }

      /**
       * Get the expiration time based on the given minutes.
       *
       * @param  int  $minutes
       * @return int
       */
      protected function expiration($minutes)
      {
          if ($minutes === 0) return 9999999999;

          return time() + ($minutes * 60);
      }

      /**
       * Get the cache key prefix.
       *
       * @return string
       */
      public function getPrefix()
      {
          return '';
      }
  }</pre>

<p>We'll also need to add the Mongo callback again to the manager:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('cache', function($app)
{
	$cache_manager = new CacheManager($app);

	$cache_manager-&gt;extend('mongo', function($app) {
		return new MongoStore(
			array(
				'host'       =&gt; $app['config']-&gt;get('cache.mongo.host'),
		        'username'   =&gt; $app['config']-&gt;get('cache.mongo.username'),
		        'password'   =&gt; $app['config']-&gt;get('cache.mongo.password'),
		        'database'   =&gt; $app['config']-&gt;get('cache.mongo.database'),
		        'collection' =&gt; $app['config']-&gt;get('cache.mongo.collection')
			)
		);
	});

	return $cache_manager;
});

$this-&gt;app-&gt;bindShared('cache.store', function($app)
{
	return $app['cache']-&gt;driver();
});

$this-&gt;app-&gt;bindShared('memcached.connector', function()
{
	return new MemcachedConnector;
});

$this-&gt;registerCommands();
	}</pre>

<p>Lastly, we'll need to update the <code>cache.php</code> config file:</p>

<pre class="brush: php">'driver' =&gt; 'mongo',
  ...
  ...
  ...
  /**
* Mongo DB settings
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_cache_collection'
	)</pre>

<p>Now, attempt to use the <code>Cache::put()</code> and <code>Cache::get()</code> methods. If done correctly, we should be able to use MongoDB to cache the data!</p>

<h2>Conclusion</h2>

<p>In this tutorial, we learned about the following:</p>

<ul><li>Laravel's component-based system called <code>Illuminate</code>, which is used by the Laravel framework.</li>
<li>Laravel Service Providers and a little bit about how they work.</li>
<li>Laravel's Manager system, which acts as both a wrapper and factory for the drivers.</li>
<li>Session, Auth and Cache components and how to create new drivers for each.</li>
<li>Store, Guard and Repository libraries which utilize these drivers.</li>
</ul>

<p>Hopefully this helps programmers create their own drivers and extend the current functionality of the Laravel framework.</p>