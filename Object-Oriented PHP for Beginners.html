<h1>PHP Orientado a Objetos para Iniciantes</h1>

<p>Para muitos programadores PHP, orientação a objetos é um conceito amedrontador, cheio de sintaxes complicadas e paradas. Com o mesmo detalhamento do meu livro, <em><a href="http://www.amazon.com/gp/product/1430228474?ie=UTF8&amp;tag=ennudesi-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1430228474">Pro PHP and jQuery,</a></em> você aprenderá os conceitos pro trás da <strong>programação orientada a objetos</strong> (POO), um estilo de codigicação onde as ações relacionadas são agrupadas em classes para ajudar na criação de códigos mais compactos e efetivos.</p>


<h2>Compreendendo a Programação Orientada a Objetos</h2>

<p>
Programação orientada a objetos é um estilo de programação que permite os desenvolvedores agrupar tarefas semelhantes em <strong>classes</strong>. Isso ajuda a nos mantermos dentro do princípio <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">"don't repeat yourself" (DRY)</a> (em português, <em>não se repita</em>) and e facilta a manutenção do mesmo.</p>

<blockquote class="pullquote pqRight">
<p>"Programação orientada a objetos é um estilo de programação que permite os desenvolvedores agrupar tarefas semelhantes em <strong>classes</strong>."</p>

</blockquote>

<p>Um dos maiors benefícios da programação DRY programming é que, se alguma informação é alterada em seu programa, geralmente, <strong>só uma mudança é necessária para atualizar o código</strong>. Um dos maiores problemas para os desenvolvedores é ter de manter códigos onde os dados são declarados e redeclarados, acarretando num jogo de pique esconde, em busca de funcionalidade e dados duplicados pelo código.</p>

<p>POO é intimidadora para uma grande quantidade de programadores porque ela introduz uma nova sintaxe e, a primeira vista, parece ser bem mais complexa que a simples programação procedural. Entretanto, se analisar bem, POO é bem direta e fundamentalmente uma abordagem mais simples para programação.</p>

<h2>Compreendendo Objetos e Classes</h2>

<p>Antes de lidar diretamente com as partes mais interessante da POO, um entendimento básico das diferenças entre <strong>objetos</strong> e <strong>classes</strong> é necessário. Essa seção falará sobre a base das classes, suas diferentes capacidades e alguns de seus usos.</p>

<h3>Reconhecendo as Diferenças Entre Objetos e Classes</h3>

<figure>
  <img src="http://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg" border="0" />
  <figcaption>Fotos por <a href="http://www.flickr.com/photos/instantjefferson/">Instant Jefferson</a> e <a href="http://www.flickr.com/photos/johnwardell/">John Wardell</a></figcaption>
</figure>

<blockquote>
<p>Quando programadores de longa data falam sobre objetos e classes, esses termos parecem permutáveis. Porém, não é bem assim.</p>
</blockquote>

<p>Logo de cara, há uma grande confusão na POO: quando programadores de longa data falam sobre objetos e classes, esses termos parecem permutáveis. Porém, não é bem assim, muito embora a diferença entre eles seja um pouco complicada de perceber, no início.</p>

<p>Uma classe, por exemplo, é como uma <strong>planta baixa para uma casa</strong>. Ela define a forma da casa no papel, com as relações entre as diferentes partes da casa, claramente, definidas e planejadas, mesmo a casa ainda não existindo.</p>

<p>Um objeto, por outro lado, <strong>seria a casa de verdade</strong>, construída de acordo com a planta baixa. Os dados guardados no objeto são como a madeira, fios e concreto que compoem a casa: sem a ordem criada pela planta baixa, são só um monte de materiais. Entretanto, quando tudo é colocado seguido uma ordem, eles viram uma casa organizada e útil.</p>

<p><strong>As classes servem de estrutura para os dados e ações, e usam essa informaçao para construir objetos.</strong> Mais de um objeto pode ser construido de uma mesma classe, ao mesmo tempo, cada um independente dos outros. Continuando a nossa analogia à construção, é parecida com a maneira que um condomínio de casa pode ser construído, usando a mesma planta baixa: 150 casas diferentes, todas bastante parecidas umas às outras, porém, contem <br />
famílias e decorações diferentes, por dentro.</p>

<h3>Estruturando Classes</h3>

<p>A sintaxe para criar uma classe é bem direta: declare-a usando a palavra chave <code>class</code>, seguida do nome da classe e um par de chaves (<code>{}</code>):</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  // As propriedades e métodos da Classe vem aqui
}

?&gt;</pre>

<p>Após criar a classe, a classe pode ser instanciada e guardada em alguma variável usando a palavra chave <code>new</code>:</p>

<pre class="brush: php">
$obj = new MyClass;</pre>

<p>Para vermos o conteúdo da classe, usamos <code>var_dump()</code>:</p>

<pre class="brush: php">
var_dump($obj);</pre>

<p>Experimente isso, colocando todo o código anterior em um único arquivo php, chamado <code>test.php</code> na sua pasta local de testes:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  // As propriedades e métodos da Classe vem aqui
}

$obj = new MyClass;

var_dump($obj);

?&gt;</pre>

<p>Carregue a página no seu navegador, usando o endereço <code>http://localhost/test.php</code> (ou o endereço indicado pelo seu servidor local) e o resultado a seguir deve aparecer:</p>

<pre class="brush: php">
object(MyClass)#1 (0) { }</pre>

<p><strong>De uma forma bem simplória, você acabou de criar seu primeiro código em POO.</strong></p>

<h2>Definindo as Propriedades da Classe</h2>

<p>Para adicionar dados à classe, usamos as <strong>propriedades</strong>, que são variáveis específicas à classe. Elas funcionam de forma parecida às variáveis normais, exceto que elas estão ligadas ao objeto e só podem ser acessadas usando o objeto.</p>

<p>Para adicionar uma propriedade a <code>MyClass</code>, adicione o seguinte trecho de código ao seu script:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou um propriedade de classe!";
}

$obj = new MyClass;

var_dump($obj);

?&gt;</pre>

<p>A palavra chave <code>public</code> determina a visibilidade da propriedade, a qual você aprenderá mais sobre, no próximo capítulo. Depois disso, a propriedade é nomeada usando os padrões básicos de nomeação de variáves, e, então, um valor é atribuído (embora propriedades de classe não necessitem de valores iniciais).</p>

<p>Para ver o valor da propriedade e mostrá-la no navegador, referencie o objeto o qual será feita a leitura, bem como a propriedade a ser lida, dessa forma:</p>

<pre class="brush: php">
echo $obj-&gt;prop1;</pre>

<p>Já que múltiplas instâncias de uma mesma classe podem existir, se um objeto em específico não for referenciado, o código não será capaz de determinar de qual objeto ler a propriedade. O uso da flecha (<code>-&gt;</code>) é um construto da POO no PHP que permite acessar as propriedades e métodos de um dado objeto.</p>

<p>Modifique o código do arquivo <code>test.php</code> para ler a propriedade ao invés de mostrar todo o conteúdo da classe, dessa forma:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou um propriedade de classe!";
}

$obj = new MyClass;

echo $obj-&gt;prop1; // Mostra a saída/conteúdo da propriedade

?&gt;</pre>

<p>Atualizando a página no seu navegador, você obtem isso, agora:</p>

<pre class="brush: php">
Sou uma propriedade de classe!</pre>

<h2>Definindo Métodos de Classe</h2>

<p><strong>Métodos</strong> são funções específicas das classes. Ações particulares que os objetos serão capazes de executar são definidas dentro das classes na forma de métodos.</p>

<p>Por exemplo, para criar métodos que atribuam e retornem o valor de uma propriedade de classe chamada <code>$prop1</code>, adicione o código a seguir:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou um propriedade de classe!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

$obj = new MyClass;

echo $obj-&gt;prop1;

?&gt;</pre>

<p><strong>Nota</strong> — POO permite que os objetos referenciem-se usando <code>$this</code>. Quando estiver dentro de um método, use <code>$this</code> da mesma forma que você usaria o nome do objeto fora da classe.</p>

<p>Para usar os métodos, execute-os da mesma forma que faria com funções normais, mas, antes, referencia o objeto ao qual eles pertencem. Para ler o valor da propriedade <code>$prop1</code> da classe <code>MyClass</code>, depois altera-lo e, por fim, le-lo novamente, faça as seguintes alterações no código:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

$obj = new MyClass;

echo $obj-&gt;getProperty(); // Lê o valor da propriedade

$obj-&gt;setProperty("Sou um novo valor da propriedade!"); // Atribui um novo valor

echo $obj-&gt;getProperty(); // Lê o valor novamente para mostrar a mudança

?&gt;</pre>

<p>Atualize a página no seu navegador e você verá o resultado a seguir:</p>

<pre class="brush: php">
Sou uma propriedade de classe!
Sou um novo valor da propriedade!</pre>

<blockquote>
<p>"O poder da POO mostra-se ao usar múltiplas instâncias da<br />
mesma classe."</p>

</blockquote>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Create two objects
$obj = new MyClass;
$obj2 = new MyClass;

// Mostra o valor de $prop1 de ambos os objetos
echo $obj-&gt;getProperty();
echo $obj2-&gt;getProperty();

// Atribui novos valores para ambos os objetos
$obj-&gt;setProperty("Sou um novo valor de propriedade!");
$obj2-&gt;setProperty("Pertenço à segunda instância!");

// Mostra o valor de $prop1 de ambos os objetos|
echo $obj-&gt;getProperty();
echo $obj2-&gt;getProperty();

?&gt;</pre>

<p>Quando atualizar a página do seu navegador, verá o resultado a seguir:</p>

<pre class="brush: php">
Sou uma propriedade de classe!
Sou uma propriedade de classe!
Sou um novo valor de propriedade!
Pertenço à segunda instância!</pre>

<p>Como pode ver, <strong>POO mantém os objetos como entidades diferentes</strong>, o que torna fácil a separação de diferentes partes de código em pedaços pequenos e relacionados.</p>

<h2>Métodos Mágicos em POO</h2>

<p>Para facilitar o uso dos objetos, o PHP provê uma série de <strong>métodos mágicos</strong>, métodos especiais chamados quando certas ações comuns ocorrem com objetos. Isso permite executar várias tarefas úteis com certa facilidade.</p>

<h3>Usando Construtores e Destruidores</h3>

<p>Quando um ojeto é isntanciado, é desejável que algumas coisas ocorram de cara. Para lidar com isso, o PHP provê o método <code>__construct()</code>, que é chamado automaticamente quando um novo objeto é<br />
criado.</p>

<p>Para ilustrar os conceitos dos construtores, adicione um construtor à classe <code>MyClass</code> que mostre uma mensagem todoa vez que uma nova instância for criada:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi instanciada!&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o valor de $prop1
echo $obj-&gt;getProperty();

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p><strong>Nota</strong> — <code>__CLASS__</code> retorna o nome da classe na qual foi usado; isso é o que chamaos de <a href="http://us3.php.net/manual/en/language.constants.predefined.php">constante mágica</a>. Há inúmeras constantes mágicas disponíveis e você pode ler mais sobre elas no <a href="http://us3.php.net/manual/en/language.constants.predefined.php">manual do PHP</a>.</p>

<p>Atualize a página no seu navegador e terá os resultados a seguir:</p>

<pre class="brush: php">
A classe "MyClass" foi instanciada!
Sou uma propriedade de classe!
Fim do arquivo.</pre>

<p>Para chamar uma função quando um objeto for destruído, o método mágico <code>__destruct()</code> está disponível. Ele é útil para finalizar as tarefas da classe (encerrar uma conexão com a base de dados, por exemplo).</p>

<p>Mostre uma mensagem quando um objeto for destruído usando o método mágico<br /><code>__destruct()</code> na class <code>MyClass</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi instanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o valor de $prop1
echo $obj-&gt;getProperty();

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>Com um método destruidor definido, atualize a página no seu navegador e verá o resultado a seguir:</p>

<pre class="brush: php">
A classe "MyClass" foi instanciada!
Sou uma propriedade de classe!
Fim do arquivo.
A classe "MyClass" foi destruída.</pre>

<blockquote>
<p>"Quando o fim do arquivo é alcançado, o PHP libera, automaticamente, todos os recursos."</p>

</blockquote>

<p>Para executar, explicitamente o método destruído, você pode destruir o objeto usando a função<br/> <code>unset()</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi isntanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o valor de $prop1
echo $obj-&gt;getProperty();

// Destrói o objeto
unset($obj);

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>Os resultados das mudanças aparecerão assim que você atualizar a página no seu navegador:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.
Fim do arquivo.</pre>

<h3>Convertendo Em Uma String</h3>

<p>Para evitar que aconteça um erro quando &ndash; e se &ndash; algum script tentar mostrar a classe MyClass como uma string, existe outro método mágico, chamado  <code>__toString()</code>.</p>

<p>Sem o método <code>__toString()</code>, <em>tentar mostrar um objeto como uma string resulta em um erro fatal</em>. Tente mostrar um objeto, usando <code>echo</code>, sem o método mágico:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi isntanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o objeto como uma string
echo $obj;

// Destrói o objeto
unset($obj);

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>O resultado é esse:</p>

<pre class="brush: php">
A classe "MyClass" foi instanciada!

Catchable fatal error: Object of class MyClass could not be converted to string in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 40</pre>

<p>Para evitar esse erro, adicione o método <code>__toString()</code> method:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi isntanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o objeto como uma string
echo $obj;

// Destrói o objeto
unset($obj);

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>Nesse caso, tentar converter o objeto em string resulta numa chamada ao método <code>getProperty()</code>. Execute o código, recarregando a página no seu navegador, e veja o resultado:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Usando o método toString: Sou uma propriedade de classe!
A classe "MyClass" foi destruída.
Fim do arquivo.</pre>

<p><strong>Dica</strong> — Além dos métodos mágicos discutidos nessa seção, inúmeros outros estão disponíveis. Para uma lista compelta com todos os métodos mágicos, veja a <a href="http://us2.php.net/manual/en/language.oop5.magic.php">respectiva página do manual do PHP</a>.</p>

<h2>Usando Herança de Classe</h2>

<p><strong>Classes podem herdar métodos e propriedades de outra classe</strong> usando a palavra chave <code>extends</code>. Por exemplo, para criar uma segunda classe que estenda <code>MyClass</code> e adicione um método, você faria dessa forma:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa o método da nova classe
echo $newobj-&gt;newMethod();

// Usa um método da classe pai
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>Após atualizar a página no seu navegador, você terá o seguinte resultado:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
De um novo método na classe MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h3>Sobrescrevendo Métodos e Propriedades Herdadas</h3>

<p>Para alterar uma propriedade ou o comportamento de um método existente na nova classe, você pode, simplesmente, sobrescreve-los, bastando redeclará-los na nova classe:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa o método da nova classe
echo $newobj-&gt;newMethod();

// Usa um método da classe pai
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>As mudanças no resultado serão:</p>

<pre class="brush: php">
Um novo construtor em MyOtherClass.
De um novo método na classe MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h3>Preservando Funcionalidades Originais de um Método Enquanto Sobrescreve o Mesmo</h3>

<p>Para adicionar uma nova funcionalidade a um método e, ao mesmo tempo, manter a funcionalidade do método original intacta, use a palavra chave <code>parent</code> juntamente ao <strong>operador de resolução de escopo</strong> (<code>::</code>):</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct(); // Invoca o construtor da classe pai
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa o método da nova classe
echo $newobj-&gt;newMethod();

// Usa um método da classe pai
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>Dessa forma, será retornado tanto o que foi codificado no construtor pai quando no construtor da nova classe:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.
De um novo método na classe MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h2>Atribuindo Visbilidade a Propriedades e Métodos</h2>

<p>Para controle adicional sobre objetos, métodos e propriedades, atribuímos visibilidades a eles. Essa visibilidade controla como e de onde as propriedades podem ser acessadas. Há três palavras chaves para visibilidade: <code>public</code>, <code>protected</code>, e <code>private</code>. Em adição à sua visibilidade, um método ou propriedade pode ser declarado como <code>static</code>, o que permite que sejam acessados sem uma instanciação da classe.</p>

<blockquote class="pullquote pqRight"><p>"Para controle adicional sobre objetos, métodos e propriedades, atribuímos visibilidades a eles."</p>

</blockquote>

<p><strong>Nota</strong> — Visibilidade é um novo recurso presente a partir do PHP 5. Para maiores informações sobre <a href="http://us2.php.net/manual/en/language.oop5.php">compatibilidade da POO com o PHP 4</a>, veja a respectiva página do manual do PHP.</p>

<h3>Métodos e Propriedades Públicas</h3>

<p>Todos os métodos e propriedades que usamos, até agora, eram públicos. Isso significa que eles podem ser acessados de qualquer lugar, tanto dentro quanto fora da classe.</p>

<h3>Métodos e Propriedades Protegidas</h3>

<p>Quando uma propriedades ou método é declarada com <code>protected</code>, <strong>ela só pode ser acessada dentro dela própria ou por uma classe descendente</strong> (classes que estendem a classe que contem o método protegido).</p>

<p>Declare o método <code>getProperty()</code> como protegido, na classe <code>MyClass</code>, e tente acessá-lo diretamente fora da classe:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  protected function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Tentativa de invocar um método protegido fora da classe
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>Quando tentar executar esse código, o erro a seguir aparece:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.

Fatal error: Call to protected method MyClass::getProperty() from context '' in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 55</pre>

<p>Agora, crie um método em <code>MyOtherClass</code> que invoque o método <code>getProperty()</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  protected function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function callProtected()
  {
      return $this-&gt;getProperty();
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Invoca o método protegido a partir de um método público
echo $newobj-&gt;callProtected();

?&gt;</pre>

<p>E, assim, temos o resultado desejado:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h3>Métodos e Propriedades Privadas</h3>

<p>Uma propriedade ou método declarado com <code>private</code> é acessível <strong>somente dentro da classe que os define</strong>. Isso significa que <em>mesmo que se uma classe estender a classe que define uma propriedade privada,</em> aquela propriedade (ou método) não será acessível na classe filha.</p>

<p>Para demonstrar isso, declare <code>getProperty()</code> como privada dentro da classe <code>MyClass</code>, e tente invocar <code>callProtected()</code> da classe<br /><code>MyOtherClass</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  private function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function callProtected()
  {
      return $this-&gt;getProperty();
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa um método da classe pai
echo $newobj-&gt;callProtected();

?&gt;</pre>

<p>Atualize a página no seu navegador e verá o erro a seguir aparecer:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.

Fatal error: Call to private method MyClass::getProperty() from context 'MyOtherClass' in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 49</pre>

<h3>Static Properties and Methods</h3>

<p>A method or property declared <code>static</code> can be accessed without first instantiating the class; you simply supply the class name, scope resolution operator, and the property or method name.</p>

<blockquote>
<p>"One of the major benefits to using static properties is that they keep their stored values for the duration of the script."</p>

</blockquote>

<p>To demonstrate this, add a static property called <code>$count</code> and a static method called <code>plusOne()</code> to <code>MyClass</code>. Then set up a <code>do...while</code> loop to output the incremented value of <code>$count</code> as long as the value is less than 10:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public static $count = 0;

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  private function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }

  public static function plusOne()
  {
      return "The count is " . ++self::$count . ".&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function callProtected()
  {
      return $this-&gt;getProperty();
  }
}

do
{
  // Call plusOne without instantiating MyClass
  echo MyClass::plusOne();
} while ( MyClass::$count &lt; 10 );

?&gt;</pre>

<p><strong>Note</strong> — When accessing static properties, the dollar sign<br />
(<code>$</code>) comes <em>after the scope resolution operator.</em></p>

<p>When you load this script in your browser, the following is output:</p>

<pre class="brush: php">
The count is 1.
The count is 2.
The count is 3.
The count is 4.
The count is 5.
The count is 6.
The count is 7.
The count is 8.
The count is 9.
The count is 10.</pre>

<h2>Commenting with DocBlocks</h2>

<blockquote class="pullquote pqRight">
<p>"The DocBlock commenting style is a widely<br />
accepted method of documenting classes."</p>

</blockquote>

<p>While not an official part of OOP, the <a href="http://en.wikipedia.org/wiki/PHPDoc">DocBlock</a> commenting style is a widely accepted method of documenting classes. Aside from providing a standard for<br />
developers to use when writing code, it has also been adopted by many of the most popular software development kits (SDKs), such as <a href="http://eclipse.org">Eclipse</a> and <a href="http://netbeans.org">NetBeans</a>, and will be used to generate code hints.</p>

<p>A DocBlock is defined by using a block comment that starts with an additional asterisk:</p>

<pre class="brush: php">
/**
 * This is a very basic DocBlock
 */</pre>

<p>The real power of DocBlocks comes with the ability to use <strong>tags</strong>, which start with an at symbol (<code>@</code>) immediately followed by the tag name and the value of the tag. <strong>DocBlock tags allow developers to define authors of a file, the license for a class, the property or method information, and other useful information.</strong></p>

<p>The most common tags used follow:</p>

<ul><li><strong>@author</strong>: The author of the current element (which might be a class, file, method, or any bit of code) are listed using this tag. Multiple author tags can be used in the same DocBlock if more than one author is credited. The format for the author name is <code>John Doe &lt;john.doe@email.com&gt;</code>.</li>
<li><strong>@copyright</strong>: This signifies the copyright year and name of the copyright holder for the current element. The format is <code>2010 Copyright Holder</code>.</li>
<li><strong>@license</strong>: This links to the license for the current element. The format for the license information is<br /><code>http://www.example.com/path/to/license.txt License Name</code>.</li>
<li><strong>@var</strong>: This holds the type and description of a variable or class property. The format is <code>type element description</code>.</li>
<li><strong>@param</strong>: This tag shows the type and description of a function or method parameter. The format is <code>type $element_name element description</code>.</li>
<li><strong>@return</strong>: The type and description of the return value of a function or method are provided in this tag. The format is <code>type return element description</code>.</li>
</ul>

<p>A sample class commented with DocBlocks might look like this:</p>

<pre class="brush: php">
&lt;?php

/**
 * A simple class
 *
 * This is the long description for this class,
 * which can span as many lines as needed. It is
 * not required, whereas the short description is
 * necessary.
 *
 * It can also span multiple paragraphs if the
 * description merits that much verbiage.
 *
 * @author Jason Lengstorf &lt;jason.lengstorf@ennuidesign.com&gt;
 * @copyright 2010 Ennui Design
 * @license http://www.php.net/license/3_01.txt PHP License 3.01
 */
class SimpleClass
{
  /**
   * A public variable
   *
   * @var string stores data for the class
   */
  public $foo;

  /**
   * Sets $foo to a new value upon class instantiation
   *
   * @param string $val a value required for the class
   * @return void
   */
  public function __construct($val)
  {
      $this-&gt;foo = $val;
  }

  /**
   * Multiplies two integers
   *
   * Accepts a pair of integers and returns the
   * product of the two.
   *
   * @param int $bat a number to be multiplied
   * @param int $baz a number to be multiplied
   * @return int the product of the two parameters
   */
  public function bar($bat, $baz)
  {
      return $bat * $baz;
  }
}

?&gt;</pre>

<p>Once you scan the preceding class, the benefits of DocBlock are apparent: everything is clearly defined so that the next developer can pick up the code and <em>never have to wonder what a snippet of code does or what it should contain.</em></p>

<h2>Comparing Object-Oriented and Procedural Code</h2>

<p>There's not really a right and wrong way to write code. That being said, <strong>this section outlines a strong argument for adopting an object-oriented approach in software development, especially in large applications.</strong></p>

<h2>Reason 1: Ease of Implementation</h2>

<blockquote class="pullquote pqRight">
<p>"While it may be daunting at first, OOP actually provides an easier approach to dealing with data."</p>

</blockquote>

<p>While it may be daunting at first, OOP actually provides an easier approach to dealing with data. Because an object can store data internally, variables don't need to be passed from function to function to work properly.</p>

<p>Also, because <em>multiple instances of the same class can exist simultaneously</em>, dealing with large data sets is infinitely easier. For instance, imagine you have two people's information being processed in a file. They need names, occupations, and ages.</p>

<h3>The Procedural Approach</h3>

<p>Here's the procedural approach to our example:</p>

<pre class="brush: php">
&lt;?php

function changeJob($person, $newjob)
{
  $person['job'] = $newjob; // Change the person's job
  return $person;
}

function happyBirthday($person)
{
  ++$person['age']; // Add 1 to the person's age
  return $person;
}

$person1 = array(
  'name' =&gt; 'Tom',
  'job' =&gt; 'Button-Pusher',
  'age' =&gt; 34
);

$person2 = array(
  'name' =&gt; 'John',
  'job' =&gt; 'Lever-Puller',
  'age' =&gt; 41
);

// Output the starting values for the people
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

// Tom got a promotion and had a birthday
$person1 = changeJob($person1, 'Box-Mover');
$person1 = happyBirthday($person1);

// John just had a birthday
$person2 = happyBirthday($person2);

// Output the new values for the people
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

?&gt;</pre>

<p>When executed, the code outputs the following:</p>

<pre class="brush: php">
Person 1: Array
(
  [name] =&gt; Tom
  [job] =&gt; Button-Pusher
  [age] =&gt; 34
)
Person 2: Array
(
  [name] =&gt; John
  [job] =&gt; Lever-Puller
  [age] =&gt; 41
)
Person 1: Array
(
  [name] =&gt; Tom
  [job] =&gt; Box-Mover
  [age] =&gt; 35
)
Person 2: Array
(
  [name] =&gt; John
  [job] =&gt; Lever-Puller
  [age] =&gt; 42
)</pre>

<p>While this code isn't necessarily bad, there's a lot to keep in mind while coding. <strong>The array of the affected person's attributes must be passed and returned from each function call</strong>, which leaves margin for error.</p>

<p>To clean up this example, it would be desirable to <strong>leave as few things up to the developer as possible.</strong> Only absolutely essential information for the current operation should need to be passed to the functions.</p>

<p><strong>This is where OOP steps in and helps you clean things up.</strong></p>

<h3>The OOP Approach</h3>

<p>Here's the OOP approach to our example:</p>

<pre class="brush: php">
&lt;?php

class Person
{
  private $_name;
  private $_job;
  private $_age;

  public function __construct($name, $job, $age)
  {
      $this-&gt;_name = $name;
      $this-&gt;_job = $job;
      $this-&gt;_age = $age;
  }

  public function changeJob($newjob)
  {
      $this-&gt;_job = $newjob;
  }

  public function happyBirthday()
  {
      ++$this-&gt;_age;
  }
}

// Create two new people
$person1 = new Person("Tom", "Button-Pusher", 34);
$person2 = new Person("John", "Lever Puller", 41);

// Output their starting point
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

// Give Tom a promotion and a birthday
$person1-&gt;changeJob("Box-Mover");
$person1-&gt;happyBirthday();

// John just gets a year older
$person2-&gt;happyBirthday();

// Output the ending values
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

?&gt;</pre>

<p>This outputs the following in the browser:</p>

<pre class="brush: php">
Person 1: Person Object
(
  [_name:private] =&gt; Tom
  [_job:private] =&gt; Button-Pusher
  [_age:private] =&gt; 34
)

Person 2: Person Object
(
  [_name:private] =&gt; John
  [_job:private] =&gt; Lever Puller
  [_age:private] =&gt; 41
)

Person 1: Person Object
(
  [_name:private] =&gt; Tom
  [_job:private] =&gt; Box-Mover
  [_age:private] =&gt; 35
)

Person 2: Person Object
(
  [_name:private] =&gt; John
  [_job:private] =&gt; Lever Puller
  [_age:private] =&gt; 42
)</pre>

<p>There's a little bit more setup involved to make the approach object oriented, but after the class is defined, creating and modifying people is a breeze; <strong>a person's information does not need to be passed or returned from methods, and only absolutely essential information is passed to each method.</strong></p>

<blockquote class="pullquote pqRight">
<p>"OOP will significantly reduce your workload if implemented properly."</p>

</blockquote>

<p>On the small scale, this difference may not seem like much, but as your applications grow in size, OOP will significantly reduce your workload if implemented properly.</p>

<p><strong>Tip</strong> — <em>Not everything needs to be object oriented.</em> A quick function that handles something small in one place inside the application does not necessarily need to be wrapped in a class. Use your best judgment when deciding between object-oriented and procedural approaches.</p>

<h2>Reason 2: Better Organization</h2>

<p>Another benefit of OOP is how well it lends itself to being <strong>easily packaged and cataloged.</strong> Each class can generally be kept in its own separate file, and if a uniform naming convention is used, accessing the classes is extremely simple.</p>

<p>Assume you've got an application with 150 classes that are called dynamically through a controller file at the root of your application filesystem. All 150 classes follow the naming convention <code>class.classname.inc.php</code> and reside in the <code>inc</code> folder of your application.</p>

<p>The controller can implement PHP's <code>__autoload()</code> function to dynamically pull in only the classes it needs as they are called, rather than including all 150 in the controller file just in case or coming up with some clever way of including the files in your own code:</p>

<pre class="brush: php">
&lt;?php
  function __autoload($class_name)
  {
      include_once 'inc/class.' . $class_name . '.inc.php';
  }
?&gt;</pre>

<p>Having each class in a separate file also makes code more portable and easier to reuse in new applications without a bunch of copying and pasting.</p>

<h2>Reason 3: Easier Maintenance</h2>

<p>Due to the more compact nature of OOP when done correctly, <strong>changes in the code are usually much easier to spot</strong> and make than in a long spaghetti code procedural implementation.</p>

<p>If a particular array of information gains a new attribute, a procedural piece of software may require (in a worst-case scenario) that the new attribute be added to each function that uses the array.</p>

<p>An OOP application could potentially be updated as easily adding the new property and then adding the methods that deal with said property.</p>

<p>A lot of the benefits covered in this section are the product of <strong>OOP in combination with DRY programming practices.</strong> It is definitely possible to create easy-to-maintain procedural code that doesn't cause nightmares, and it is equally possible to create awful object-oriented code. [<em>Pro PHP and  jQuery</em>] will attempt to demonstrate a combination of good coding habits in conjunction with OOP to generate clean code that's easy to read and maintain.</p>

<h2>Summary</h2>

<p>At this point, you should feel comfortable with the object-oriented programming style. Learning OOP is a great way to take your programming to that next level. When implemented properly, OOP will help you produce easy-to-read, easy-to-maintain, portable code that will save you (and the developers who work with you) hours of extra work. Are you stuck on something that wasn't covered in this article? Are you already using OOP and have some tips for beginners? Share them in the comments!</p>

<p><strong>Author's Note</strong> — This tutorial was an excerpt from <a href="http://www.amazon.com/gp/product/1430228474?ie=UTF8&amp;tag=ennudesi-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1430228474">Pro PHP and jQuery</a> (Apress, 2010).</p>
