<h1>Princípios SOLID Parte 3 - Princípios da Substituição de Liskov e Segregação de Interfaces</h1>

<p><a href="http://net.tutsplus.com/tutorials/php/solid-part-1-the-single-responsibility-principle/">Responsabilidade Única (SRP - Single Responsability)</a>, <a href="http://net.tutsplus.com/tutorials/php/solid-part-2-the-openclosed-principle/">berto para Expansão, Fechado para Modificações (Open/Close)</a>, <em>Substituição de Liskov e Segregação de Interfaces,</em> e Inversão de Dependência (Dependency Inversion). Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<p>Pelos Princípios da Substituição de Liskov (Liskov Substitution Principle - LSP) e da Segregação de Interfaces (Interface Segregation Principle - ISP) serem bem simples de definir e exemplificar, nessa lição, nós falaremos dos dois.</p>

<h2>Princípio da Substituição de Liskov (LSP)</h2>

<blockquote>
	<p>Classes filhas nunca deveriam infringir as definições de tipo da classe pai.</p>
</blockquote>

<p>O conceito desse princípio foi apresentado por Barbara Liskov em uma apresentação de uma conferência em 1987, e depois publicada em um artigo científico, junto de Jannette Wing, em 1994. A definição original é a que segue:</p>

<blockquote>
	<p>Seja q(x) uma propriedade provável de objetos x do tipo T. Então, q(y) deve ser provável para o objeto y do tipo S onde S é um subtipo de T.</p>
</blockquote>

<p>Pouco depois, com a publicação dos princípios SOLID por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em eu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e republicado na versão usando C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, a definição ficou conhecida como o Princípio de Substituição de Liskov. </p>

<p>O que nos leva à definição apresentada porRobert C. Martin:</p>

<blockquote>
	<p>Subtipos devem ser substituíveis pelos seus tipos base.</p>
</blockquote>

<p>Tão simples quanto você vê, uma subclasse deve sobrescrever os métodos da classe pai, de tal maneira que não quebre a funcionalidade do ponto de vista do cliente. Eis um exemplo que demonstra o conceito.</p>

<pre class="brush: php">class Vehicle {

	function startEngine() {
		// Funcionalidade de inicialização padrão do motor
	}

	function accelerate() {
		// Funcionalidade de aceleração padrão
	}
}</pre>

<p>Dada uma classe <code>Vehicle</code> - ela pode ser abstrata - e duas implementaçõesand:</p>

<pre class="brush: php">class Car extends Vehicle {

	function startEngine() {
		$this-&gt;engageIgnition();
		parent::startEngine();
	}

	private function engageIgnition() {
		// Procedimento de ignição
	}

}

class ElectricBus extends Vehicle {

	function accelerate() {
		$this-&gt;increaseVoltage();
		$this-&gt;connectIndividualEngines();
	}

	private function increaseVoltage() {
		// Lógica elétrica
	}

	private function connectIndividualEngines() {
		// Lógica de conexão
	}

}</pre>

<p>Uma classe cliente deve ser capaz de usar qualquer uma das duas implementações, se a classe cliente for capaz de usar a classe <code>Vehicle</code>.</p>

<pre class="brush: php">class Driver {
	function go(Vehicle $v) {
		$v-&gt;startEngine();
		$v-&gt;accelerate();
	}
}</pre>

<p>O que nos leva a uma implementação simples do Padrão de Projeto do Método Modelo, como vimos no tutorial do princípio passado, o OCP.</p>

<figure>
<img width="600" alt="template_method" src="http://cdn.tutsplus.com/net/uploads/2014/01/template_method1.png" height="294"><br>
</figure>

<p>Baseados em nossa experiência anterior com o Princípio do Aberto para Expansão, Fechado para Modificação, nós podemos concluir que o Princípio da Substituição de Liskov é bastante relacionado ao OCP. Na verdade, "uma violação do LSP é uma violação latente ao OCP" (Robert C. Martin), e o Padrão de Projeto do Método Modelo é um clássico exemplo de respeito e implementação do LSP, que, em troca, é uma das soluções para implementar o OCP também.</p>

<h2>The Classic Example of LSP Violation</h2>

<p>To illustrate this completely, we will go with a classic example because it is highly significant and easily understandable.</p>

<pre class="brush: php">class Rectangle {

	private $topLeft;
	private $width;
	private $height;

	public function setHeight($height) {
		$this-&gt;height = $height;
	}

	public function getHeight() {
		return $this-&gt;height;
	}

	public function setWidth($width) {
		$this-&gt;width = $width;
	}

	public function getWidth() {
		return $this-&gt;width;
	}

}</pre>

<p>We start with a basic geometrical shape, a <code>Rectangle</code>. It is just a simple data object with setters and getters for <code>width</code> and <code>height</code>. Imagine that our application is working and it is already deployed to several clients. Now they need a new feature. They need to be able to manipulate squares.</p>

<p>In real life, in geometry, a square is a particular form of rectangle. So we could try to implement a <code>Square</code> class that extends a <code>Rectangle</code> class. It is frequently said that a child class <em>is a</em> parent class, and this expression also conforms to LSP, at least at first sight.</p>

<figure>
<img width="178" alt="SquareRect" src="http://cdn.tutsplus.com/net/uploads/2014/01/SquareRect.png" height="259"><br>
</figure>

<p>But is a <code>Square</code> really a <code>Rectangle</code> in programming?</p>

<pre class="brush: php">class Square extends Rectangle {

	public function setHeight($value) {
		$this-&gt;width = $value;
		$this-&gt;height = $value;
	}

	public function setWidth($value) {
		$this-&gt;width = $value;
		$this-&gt;height = $value;
	}
}</pre>

<p>A square is a rectangle with equal width and height, and we could do a strange implementation like in the above example. We could overwrite both setters to set the height as well as the width. But how would that affect client code?</p>

<pre class="brush: php">class Client {

	function areaVerifier(Rectangle $r) {
		$r-&gt;setWidth(5);
		$r-&gt;setHeight(4);

		if($r-&gt;area() != 20) {
			throw new Exception('Bad area!');
		}

		return true;
	}

}</pre>

<p>It is conceivable to have a client class that verifies the rectangle's area and throws an exception if it is wrong.</p>

<pre class="brush: php">function area() {
	return $this-&gt;width * $this-&gt;height;
}</pre>

<p>Of course we added the above method to our <code>Rectangle</code> class to provide the area.</p>

<pre class="brush: php">class LspTest extends PHPUnit_Framework_TestCase {

	function testRectangleArea() {
		$r = new Rectangle();
		$c = new Client();
		$this-&gt;assertTrue($c-&gt;areaVerifier($r));
	}

}</pre>

<p>And we created a simple test by sending an empty rectangle object to area verifier and the test passes. If our <code>Square</code> class is correctly defined, sending it to the Client's <code>areaVerifier()</code> should not break its functionality. After all, a <code>Square</code> is a <code>Rectangle</code> in all mathematical sense. But is our class?</p>

<pre class="brush: php">function testSquareArea() {
	$r = new Square();
	$c = new Client();
	$this-&gt;assertTrue($c-&gt;areaVerifier($r));
}</pre>

<p>Testing it is very easy and it breaks big time. An exception is thrown to us when we run the test above.</p>

<pre class="brush: bash">PHPUnit 3.7.28 by Sebastian Bergmann.

Exception : Bad area!
#0 /paht/: /.../.../LspTest.php(18): Client-&gt;areaVerifier(Object(Square))
#1 [internal function]: LspTest-&gt;testSquareArea()</pre>

<p>So, our <code>Square</code> class is not a <code>Rectangle</code> after all. It breaks the laws of geometry. It fails and it violates the Liskov Substitution Principle.</p>

<p>I especially love this example because it not only violates LSP, it also demonstrates that object oriented programming is not about mapping real life to objects. Each object in our program must be an abstraction over a concept. If we try to map one-to-one real objects to programmed objects, we will almost always fail.</p>

<h2>The Interface Segregation Principle</h2>

<p>The Single Responsibility Principle is about actors and high level architecture. The Open/Closed Principle is about class design and feature extensions. The Liskov Substitution Principle is about subtyping and inheritance. The Interface Segregation Principle (ISP) is about business logic to clients communication.</p>

<p>In all modular applications there must be some kind of interface that the client can rely on. These may be actual Interface typed entities or other classic objects implementing design patterns like Facades. It doesn't matter which solution is used. It always has the same scope: to communicate to the client code on how to use the module. These interfaces can reside between different modules in the same application or project, or between one project as a third party library serving another project. Again, it doesn't matter. Communication is communication and clients are clients, regardless of the actual individuals writing the code.</p>

<p>So, how should we define these interfaces? We could think about our module and expose all the functionalities we want it to offer.</p>

<figure>
<img width="277" alt="hugeInterface" src="http://cdn.tutsplus.com/net/uploads/2014/01/hugeInterface.png" height="580"><br>
</figure>

<p>This looks like a good start, a great way to define what we want to implement in our module. Or is it? A start like this will lead to one of two possible implementations:</p>

<ul>
<li>A huge <code>Car</code> or <code>Bus</code> class implementing all the methods on the <code>Vehicle</code> interface. Only the sheer dimensions of such classes should tell us to avoid them at all costs.</li>
<li>Or, many small classes like <code>LightsControl</code>, <code>SpeedControl</code>, or <code>RadioCD</code> which are all implementing the whole interface but actually providing something useful only for the parts they implement.</li>
</ul>

<p>It is obvious that neither solution is acceptable to implement our business logic.</p>

<figure>
<img width="600" alt="specializedImplementationInterface" src="http://cdn.tutsplus.com/net/uploads/2014/01/specializedImplementationInterface.png" height="413"><br>
</figure>

<p>We could take another approach. Break the interface into pieces, specialized to each implementation. This would help to use small classes that care about their own interface. The objects implementing the interfaces will be used by the different type of vehicles, like car in the image above. The car will use the implementations but will depend on the interfaces. So a schema like the one below may be even more expressive.</p>

<figure>
<img width="600" alt="carUsingInterface" src="http://cdn.tutsplus.com/net/uploads/2014/01/carUsingInterface.png" height="423"><br>
</figure>

<p>But this fundamentally changes our perception of the architecture. The <code>Car</code> becomes the client instead of the implementation. We still want to provide to our clients ways to use our whole module, that being a type of vehicle.</p>

<figure>
<img width="600" alt="oneInterfaceManyClients" src="http://cdn.tutsplus.com/net/uploads/2014/01/oneInterfaceManyClients.png" height="339"><br>
</figure>

<p>Assume we solved the implementation problem and we have a stable business logic. The easiest thing to do is to provide a single interface with all the implementations and let the clients, in our case <code>BusStation</code>, <code>HighWay</code>, <code>Driver</code> and so on, to use whatever thew want from the interface's implementation. Basically, this shifts the behavior selection responsibility to the clients. You can find this kind of solution in many older applications.</p>

<blockquote><p>The interface-segregation principle (ISP) states that no client should be forced to depend on methods it does not use.</p>
</blockquote>

<p>However, this solution has its problems. Now all the clients depend on all the methods. Why should a <code>BusStation</code> depend on the state of lights of the bus, or on the radio channels selected by the driver? It should not. But what if it does? Does it matter? Well, if we think about the Single Responsibility Principle, it is a sister concept to this one. If <code>BusStation</code> depends on many individual implementations, not even used by it, it may require changes if any of the individual small implementations change. This is especially true for compiled languages, but we can still see the effect of the <code>LightControl</code> change impacting <code>BusStation</code>. These things should never happen.</p>

<p>Interfaces belong to their clients and not to the implementations. Thus, we should always design them in a way to best suite our clients. Some times we can, some times we can not exactly know our clients. But when we can, we should break our interfaces in many smaller ones, so they better satisfy the exact needs of our clients.</p>

<figure>
<img width="600" alt="segregatedInterfaces" src="http://cdn.tutsplus.com/net/uploads/2014/01/segregatedInterfaces.png" height="406"><br>
</figure>

<p>Of course, this will lead to some degree of duplication. But remember! Interfaces are just plain function name definitions. There is no implementation of any kind of logic in them. So the duplications is small and manageable.</p>

<p>Then, we have the great advantage of clients depending only and only on what they actually need and use. In some cases, clients may use and need several interfaces, that is OK, as long as they use all the methods from all the interfaces they depend on.</p>

<p>Another nice trick is that in our business logic, a single class can implement several interfaces if needed. So we can provide a single implementation for all the common methods between the interfaces. The segregated interfaces will also force us to think of our code more from the client's point of view, which will in turn lead to loose coupling and easy testing. So, not only have we made our code better to our clients, we also made it easier for ourselves to understand, test and implement.</p>

<h2>Final Thoughts</h2>

<p>LSP taught us why reality can not be represented as a one-to-one relation with programmed objects and how subtypes should respect their parents. We also put it in light of the other principles that we already knew.</p>

<p>ISP teaches us to respect our clients more than we thought necessary. Respecting their needs will make our code better and our lives as programmers easier.</p>

<p>Thank you for your time.</p>
