<h1>Princípios SOLID Parte 3 - Princípios da Substituição de Liskov e Segregação de Interfaces</h1>

<p><a href="http://net.tutsplus.com/tutorials/php/solid-part-1-the-single-responsibility-principle/">Responsabilidade Única (SRP - Single Responsability)</a>, <a href="http://net.tutsplus.com/tutorials/php/solid-part-2-the-openclosed-principle/">berto para Expansão, Fechado para Modificações (Open/Close)</a>, <em>Substituição de Liskov e Segregação de Interfaces,</em> e Inversão de Dependência (Dependency Inversion). Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<p>Pelos Princípios da Substituição de Liskov (Liskov Substitution Principle - LSP) e da Segregação de Interfaces (Interface Segregation Principle - ISP) serem bem simples de definir e exemplificar, nessa lição, nós falaremos dos dois.</p>

<h2>Princípio da Substituição de Liskov (LSP)</h2>

<blockquote>
	<p>Classes filhas nunca deveriam infringir as definições de tipo da classe pai.</p>
</blockquote>

<p>O conceito desse princípio foi apresentado por Barbara Liskov em uma apresentação de uma conferência em 1987, e depois publicada em um artigo científico, junto de Jannette Wing, em 1994. A definição original é a que segue:</p>

<blockquote>
	<p>Seja q(x) uma propriedade provável de objetos x do tipo T. Então, q(y) deve ser provável para o objeto y do tipo S onde S é um subtipo de T.</p>
</blockquote>

<p>Pouco depois, com a publicação dos princípios SOLID por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em eu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e republicado na versão usando C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, a definição ficou conhecida como o Princípio de Substituição de Liskov. </p>

<p>O que nos leva à definição apresentada porRobert C. Martin:</p>

<blockquote>
	<p>Subtipos devem ser substituíveis pelos seus tipos base.</p>
</blockquote>

<p>Tão simples quanto você vê, uma subclasse deve sobrescrever os métodos da classe pai, de tal maneira que não quebre a funcionalidade do ponto de vista do cliente. Eis um exemplo que demonstra o conceito.</p>

<pre class="brush: php">class Vehicle {

	function startEngine() {
		// Funcionalidade de inicialização padrão do motor
	}

	function accelerate() {
		// Funcionalidade de aceleração padrão
	}
}</pre>

<p>Dada uma classe <code>Vehicle</code> - ela pode ser abstrata - e duas implementaçõesand:</p>

<pre class="brush: php">class Car extends Vehicle {

	function startEngine() {
		$this-&gt;engageIgnition();
		parent::startEngine();
	}

	private function engageIgnition() {
		// Procedimento de ignição
	}

}

class ElectricBus extends Vehicle {

	function accelerate() {
		$this-&gt;increaseVoltage();
		$this-&gt;connectIndividualEngines();
	}

	private function increaseVoltage() {
		// Lógica elétrica
	}

	private function connectIndividualEngines() {
		// Lógica de conexão
	}

}</pre>

<p>Uma classe cliente deve ser capaz de usar qualquer uma das duas implementações, se a classe cliente for capaz de usar a classe <code>Vehicle</code>.</p>

<pre class="brush: php">class Driver {
	function go(Vehicle $v) {
		$v-&gt;startEngine();
		$v-&gt;accelerate();
	}
}</pre>

<p>O que nos leva a uma implementação simples do Padrão de Projeto do Método Modelo, como vimos no tutorial do princípio passado, o OCP.</p>

<figure>
<img width="600" alt="template_method" src="http://cdn.tutsplus.com/net/uploads/2014/01/template_method1.png" height="294"><br>
</figure>

<p>Baseados em nossa experiência anterior com o Princípio do Aberto para Expansão, Fechado para Modificação, nós podemos concluir que o Princípio da Substituição de Liskov é bastante relacionado ao OCP. Na verdade, "uma violação do LSP é uma violação latente ao OCP" (Robert C. Martin), e o Padrão de Projeto do Método Modelo é um clássico exemplo de respeito e implementação do LSP, que, em troca, é uma das soluções para implementar o OCP também.</p>

<h2>O Exemplo Clássico de Violação ao LSP</h2>

<p>Para ilustrar isso completamente, nós mostraremos um exemplo clássico, uma vez que ele é bastante significante e facilmente compreensível.</p>

<pre class="brush: php">class Rectangle {

	private $topLeft;
	private $width;
	private $height;

	public function setHeight($height) {
		$this-&gt;height = $height;
	}

	public function getHeight() {
		return $this-&gt;height;
	}

	public function setWidth($width) {
		$this-&gt;width = $width;
	}

	public function getWidth() {
		return $this-&gt;width;
	}

}</pre>

<p>Começamos com uma forma geométrica básica, um <code>Rectangle</code>. Ela é um simples objeto de dados com <code>setters</code> e <code>getters</code> para <code>width</code> (largura) e <code>height</code> (altura). Imagine que nossa aplicação está em funcionamento e já está implantada em diversos clientes. Agora, eles precisam de uma nova funcionalidade. Eles precisam ser capazes de manipular quadrados.</p>

<p>Na vida real, na geometria, um quadrado é um tipo especial de retângulo. Então, nós podemos tentar implementar uma classe <code>Square</code> (quadrado) que estende a classe <code>Rectangle</code>. Frequentemente, diz-se que uma classe filha <em>é uma</em> classe pai, e essa expressão também se sujeita ao LSP, pelo menos à primeira vista.</p>

<figure>
<img width="178" alt="SquareRect" src="http://cdn.tutsplus.com/net/uploads/2014/01/SquareRect.png" height="259"><br>
</figure>

<p>Mas, uma classe <code>Square</code> é uma classe <code>Rectangle</code>, programaticamente falando?</p>

<pre class="brush: php">class Square extends Rectangle {

	public function setHeight($value) {
		$this-&gt;width = $value;
		$this-&gt;height = $value;
	}

	public function setWidth($value) {
		$this-&gt;width = $value;
		$this-&gt;height = $value;
	}
}</pre>

<p>Uma quadrado é um retângulo com largura e alturas iguais, e poderíamos criar essa implementação esquisita que vemos no exemplo acima. Poderíamos sobrescrever ambos os <code>setter</code>s para atribuir tanto a altura quanto a largura, juntas. Mas, como isso afetaria o código cliente?</p>

<pre class="brush: php">class Client {

	function areaVerifier(Rectangle $r) {
		$r-&gt;setWidth(5);
		$r-&gt;setHeight(4);

		if($r-&gt;area() != 20) {
			throw new Exception('Área errada!');
		}

		return true;
	}

}</pre>

<p>É aceitável que exista uma classe cliente que verifique a área de um retângulo e lance uma exceção se a área estiver errada.</p>

<pre class="brush: php">function area() {
	return $this-&gt;width * $this-&gt;height;
}</pre>

<p>Claro, adicionamos o método acima à nossa classe <code>Rectangle</code> para prover a área.</p>

<pre class="brush: php">class LspTest extends PHPUnit_Framework_TestCase {

	function testRectangleArea() {
		$r = new Rectangle();
		$c = new Client();
		$this-&gt;assertTrue($c-&gt;areaVerifier($r));
	}

}</pre>

<p>E nós criamos um testes simples, enviando um objeto retângulo vazio para o método verificador de área e ele passa. Se nossa classe <code>Square</code> estiver definida corretamente, enviá-la para o método <code>areaVerifier()</code> da classe cliente não deveria quebrar sua funcionalidade. Afinal, uma classe <code>Square</code> é uma classe <code>Rectangle</code> em todos os sentidos matemáticos. Mas, e nos sentigos programáticos?</p>

<pre class="brush: php">function testSquareArea() {
	$r = new Square();
	$c = new Client();
	$this-&gt;assertTrue($c-&gt;areaVerifier($r));
}</pre>

<p>Testá-lo é bem simples e veremos que ele falhará fácil, fácil. Uma exceção é lançada quando executarmos o teste acima.</p>

<pre class="brush: bash">PHPUnit 3.7.28 by Sebastian Bergmann.

Exception : Área errada!
#0 /paht/: /.../.../LspTest.php(18): Client-&gt;areaVerifier(Object(Square))
#1 [internal function]: LspTest-&gt;testSquareArea()</pre>

<p>Então, nossa classe <code>Square</code> não é uma classe <code>Rectangle</code>, no fim das contas. Ela quebra as leis da geometria. Ela falha e viola o Princípio de Substituição de Liskov.</p>

<p>Gosto bastante desse exemplo porque ele não só violá o LSP, mas também demostra que a programação orientada a objetos não se trata de mapear itens da vida real em objetos. Cada objeto em nosso programa deve ser uma abstração de um conceito. Se tentarmos mapear objetos da vida real, um a um, com objetos programáticos, nós, praticamente, falharemos.</p>

<h2>O Princípio da Segregação de Interfaces</h2>

<p>O Princípio da Responsabilidade Única é sobre atores e estruturas de alto nível. O Princípio do Aberto para Expansão, Fechado para Modificação, é sobre projeto de classes e extensão de funcionalidades. O Princípio de Substituição de Liskov é sobre subtipos e herança. O Princípio da Segregação de Interfaces (ISP) é sobre lógica de negócios relacionada a comunicação com clientes.</p>

<p>Em todas aplicações modulares, deve existir algum tipo de interface que o cliente possa contar. Talvez essa sejam entidades do tipo Interface ou outros objetos clássicos implementando padrões de projeto como Facades. Nã importa qual a solução usada. Sempre é o mesmo escopo: mostrar ao código cliente como usar um módulo. Essas interfaces podem ficar entre módulos diferentes na mesma aplicação ou projeto,ou entre um projeto e uma biblioteca de terceiros, servido outro projeto. Novamente, não interessa. Comunicação é comunicação, e clientes são clientes, independente de quem esteja escrevendo os códigos.</p>

<p>Então, como nós definiríamos essas interfaces? Poderíamos pensar em nosso módulo e expor todas as funcionalidades que quisermos oferecer.</p>

<figure>
<img width="277" alt="hugeInterface" src="http://cdn.tutsplus.com/net/uploads/2014/01/hugeInterface.png" height="580"><br>
</figure>

<p>Isso parece um bom começo, uma ótima maneira de como implementar nosso módulo. Será que é? Um começo como esse levará a um de dois tipos de implementações:</p>

<ul>
<li>Uma classe carro <code>Car</code> ou <code>Bus</code> gigante, implementando todos os métodos da interface <code>Vehicle</code>. Somente as dimensões mais simples de tais classes devem dizer se devemos evita-las a todo custo.</li>
<li>Ou, muitas classes pequenas, como as classes <code>LightsControl</code>, <code>SpeedControl</code>, ou <code>RadioCD</code>, as quais todas implementam toda a interface, porém, provendo algo de útil somente para as partes que eles implementam.</li>
</ul>

<p>É claro que nenhuma das solução é aceitável para implementar a lógica do nosso negócio.</p>

<figure>
<img width="600" alt="specializedImplementationInterface" src="http://cdn.tutsplus.com/net/uploads/2014/01/specializedImplementationInterface.png" height="413"><br>
</figure>

<p>Nós poderíamos escolher outra abordagem. Divida a interface em partes, especializada para cada implementação. Isso ajudaria a criar e usar pequenas classes que importam-se com suas próprias interfaces. Os objetos implementando as interfaces serão usados pelos diferentes tipos de veículos, como o carro na imagem acima. O carro usará as implementações mas dependerá das interfaces. Assim, um esquema como o de logo abaixo é ainda mais expressivo.</p>

<figure>
<img width="600" alt="carUsingInterface" src="http://cdn.tutsplus.com/net/uploads/2014/01/carUsingInterface.png" height="423"><br>
</figure>

<p>Mas isso muda, fundamentalmente, nossa percepção da aruitetura. A classe <code>Car</code> torna-se o cliente ao invés da implementação. Nós ainda queremos prover a nossos clientes, maneiras para usarem nosso módulo por inteiro, aquele que é um veículo.</p>

<figure>
<img width="600" alt="oneInterfaceManyClients" src="http://cdn.tutsplus.com/net/uploads/2014/01/oneInterfaceManyClients.png" height="339"><br>
</figure>

<p>Assuma que resolvemos o problema da implementação e temos uma lógica de negócios estável. A coisa mais fácil a fazer é prover uma única interface com todas as implementações de deixar o cliente, em nosso caso, as classes <code>BusStation</code>, <code>HighWay</code>, <code>Driver</code> aí em diante, a usar o que quer que eles queiram da implementação de nossa interface. Basicamente, isso passa a responsabilidade de seleção de comportamento para os clientes. Você é capaz de encontrar esse tipo de solução em várias aplicações mais antigas.</p>

<blockquote><p>O Princípio da Segregação de Interface (ISP) afirma que nenhum cliente deve ser forçado a depender de métodos que ele não use.</p>
</blockquote>

<p>However, this solution has its problems. Now all the clients depend on all the methods. Why should a <code>BusStation</code> depend on the state of lights of the bus, or on the radio channels selected by the driver? It should not. But what if it does? Does it matter? Well, if we think about the Single Responsibility Principle, it is a sister concept to this one. If <code>BusStation</code> depends on many individual implementations, not even used by it, it may require changes if any of the individual small implementations change. This is especially true for compiled languages, but we can still see the effect of the <code>LightControl</code> change impacting <code>BusStation</code>. These things should never happen.</p>

<p>Interfaces belong to their clients and not to the implementations. Thus, we should always design them in a way to best suite our clients. Some times we can, some times we can not exactly know our clients. But when we can, we should break our interfaces in many smaller ones, so they better satisfy the exact needs of our clients.</p>

<figure>
<img width="600" alt="segregatedInterfaces" src="http://cdn.tutsplus.com/net/uploads/2014/01/segregatedInterfaces.png" height="406"><br>
</figure>

<p>Of course, this will lead to some degree of duplication. But remember! Interfaces are just plain function name definitions. There is no implementation of any kind of logic in them. So the duplications is small and manageable.</p>

<p>Then, we have the great advantage of clients depending only and only on what they actually need and use. In some cases, clients may use and need several interfaces, that is OK, as long as they use all the methods from all the interfaces they depend on.</p>

<p>Another nice trick is that in our business logic, a single class can implement several interfaces if needed. So we can provide a single implementation for all the common methods between the interfaces. The segregated interfaces will also force us to think of our code more from the client's point of view, which will in turn lead to loose coupling and easy testing. So, not only have we made our code better to our clients, we also made it easier for ourselves to understand, test and implement.</p>

<h2>Final Thoughts</h2>

<p>LSP taught us why reality can not be represented as a one-to-one relation with programmed objects and how subtypes should respect their parents. We also put it in light of the other principles that we already knew.</p>

<p>ISP teaches us to respect our clients more than we thought necessary. Respecting their needs will make our code better and our lives as programmers easier.</p>

<p>Thank you for your time.</p>
