<h1>Princípos SOLID Parte 4 - Princípio da Inversão de Dependência</h1>

<p><a href="http://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Responsabilidade Única (SRP - Single Responsability)</a>, <a href="http://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600">Aberto para Expansão, Fechado para Modificações (Open/Close)</a>, <a href="http://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Substituição de Liskov (Liskov's Substitution), Segregação de Interface (Interface Segregation);</a> e <em>Inversão de Dependência (Dependency Inversion)</em>. Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<p>Não seria justo dizer que qualquer um dos princípios SOLID fosse mais importante que os outros. Contudo, é bem provável que nenhum dos outros princípios tenha efeito tão imediato e profundo em seu código quanto o Princípio da Inversão de Dependência (Dependency Inversion Principle - DIP). Se você acha os outros princípios difíceis de entender e aplicar, comece com esse daqui e aplique os outros princípios nos códigos que respeitem o DIP.</p>

<h2>Definição</h2>

<blockquote><p>A. Módulos de alto nível não deveriam depender em módulos de baixo nível. Ambos deveriam depender de abstrações.<br>
B. Abstrações não deveriam depender de detalhes. Detalhes devem depender de abstrações.</p>
</blockquote>

<p>Esse princípio foi definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e depois na versão em C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, e é o último dos cinco princípios ágeis SOLID.</p>

<h2>DIP no Mundo Real</h2>

<p>Antes de começarmos a codificar algo, quero contar-lhes uma história. Lá na Syneto, não fomos, sempre, cuidados com os códigos que criamos. Alguns anos atrás, sabíamos menos e, embora puséssemos o melhor de nós, nem todos nossos projetos eram legais. Nós fomos ao inferno e voltamos, e aprendemos algumas coisas, na tentativa e erro.</p>

<p>Os princípios SOLID e a clara arquitetura do Tio Bob (Robert C. Martin) mudaram nossa situação, e transformaram a maneira como codificamos, de tal forma, que é difícil de descrever. Tentarei explicar, de forma simples, algumas decisões arquiteturais impostas pelo DIP que tiveram um grande impacto em nossos projetos.</p>

<p>A maioria dos projetos web contém três tecnologias principais: HTML, PHP, e SQL. As versões específicas dessas tecnologias ou o tipo da implementação SQL que usamos, são irrelevantes. O ponto é, a informação em um formulário HTML deve acabar, de uma forma ou de outra, no banco de dados. A "cola" necessária entre os dois, pode ser dado pelo PHP.</p>

<p>O que é preciso entender dessa situação, é como essas três tecnologias representam tão bem três camadas arquiteturais diferentes: interface do usuário, lógica de negócios e persistência. Nós trataremos sobre as implicações dessas três camadas em um minuto. Por hora, foquemos numa forma esquisita e frequentente vista para fazer essas tecnologias trabalharem juntas.</p>

<p>Já vi diversos projetos que usam código SQL em um script PHP, dentro de um arquivo HTML, ou, ainda, códigos PHP imprimindo páginas e mais páginas de HTML, interpretando, diretamente, variáveis globais de <code>$_GET</code> ou <code>$_POST</code>. Mas, por que isso é ruim?</p>

<figure>
<img width="600" alt="html-php-sql-cross-dependencies" src="http://cdn.tutsplus.com/net/uploads/2014/02/html-php-sql-cross-dependencies.png" height="423"><br>
</figure>

<p>As imagens acima representam uma versão bem crua do que descrevemos no parágrafo anterior. As setas representam várias dependências e, podemos concluir que, basicamente, tudo depende tudo. Se precisamos mudar uma tabela da base de dados, talvez tenhamos de alterar até algum arquivo HTML. Ou, se mudarmos algum campo de formulário no HTML, nós talvez precisemos mudar o nome de alguma coluna em alguma instrução SQL. Ou, se aprendermos algum outro esquema, talvez precisemos mudar nosso código PHP se o HTML mudar, ou, em casos bem ruins, se geramos o HTML a partir de um arquivo PHP, é certo que tenhamos de modificar o código PHP para modificar o HTML. Então, não há dúvidas, as dependências estão ziguezagueando entre as clsses e módulos. Mas, não acaba aí. Você pode ter procedimentos armazenados: Código PHP em tabelas SQL.</p>

<figure>
<img width="600" alt="html-php-sql-stored-procedures" src="http://cdn.tutsplus.com/net/uploads/2014/02/html-php-sql-stored-procedures.png" height="503"><br>
</figure>

<p>No esquema acima, as consultas SQL na base de dados retornam código PHP gerado com os dados vindos das tabelas. Essas funções ou classes PHP executam outras consultas SQL que retornam outros códigos PHP, e o ciclo continua até, finalmente, toda a informação obtida é retornada... provavelmente para a Interface do Usuário.</p>

<p>Sei que isso pode parecer terrível para a maioria de vocês, mas, se você não trabalhou com um projeto inventado e implementado dessa forma, você, provavelmente, irá em algum projeto futuro. A maioria dos projetos existentes, independente da linguagem de programação usada, foram escritos com antigos princípios em mente, por programadores que não se importavam ou não sabiam como fazer melhor. Se você está lendo esses tutoriais, você, certamente, está um nível acima. Você está pronto ou preparando-se para respeitar seu trabalho, abraçar sua arte e fazer mais e melhor.</p>

<p>A outra opção é repetir os erros de seus predecessores cometeram e viver com as consequências. Lá na Syneto, depois que um de nossos projetos alcançou um estado de uma manutenção quase que impraticável, devido a sua arquitetura antiga e interdependente, tivemos de abandoná-la para sempre, nós decidimos que não queríamos seguir aquele caminho, novamente. Desde então, nós buscamos uma arquitetura clara, que respeita os princípios SOLID e, de forma mais importante, o Princípio da Inversão de Dependência.</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2014/02/HighLevelDesign.png" height="388"><br>
</figure>

<p>O que é tão maravilhos sobre essa arquitetura é como as dependências estão apontando:</p>

<ul>
<li>A interface do usuário (na maioria dos casos, uma *framework* MVC) ou qualquer outro mecanismo de entrega que exista em seu projeto, dependerá da lógica de negócio. A lógica de negócio é bem abstrata. A interface do usuário é bem concreta. A interface do usuário é apenas um detalhe no projeto e também é bastante volátil. Nada deveria depender da interface do usuário, nada deveria depender da sua *framework* MVC.</li>
<li>Outra observação importante que podemos fazer é que a persistência, a base de dados, seu MySQL ou PostgreSQL, depende da lógica de negócio. Sua lógica de negócio é agnóstica em relação a base de dados. Isso permite troca o método de persistência quando e como quiser. Se, amanhã, você quiser mudar do MySQL/PostgreSQL para arquivos de texto, você pode fazer isso. Claro, você terá de implementar uma camada específica de persistência para esse novo método, mas não precisará mudar um única linha da sua lógica de negócio. Há uma explicação muito mais detalhada sobre persistência no tutorial <a href="http://code.tutsplus.com/tutorials/evolving-toward-a-persistence-layer--net-27138">Evolving Toward a Persistence Layer</a>.</li>
<li>Finalmente, do lado direito da lógica de negócios, na parte externa, nós temos todas as classes que criam as classes para a lógica de negócios. Essas são "fábricas" e classes criadas pelo ponto de entrada da aplicação. Muitas pessoas acreditam que essas classes pertencem à lógica de negócios, mas, enquanto criarem objetos de negócio, o único motivo de existência deles é esse. Elas são classes que nos ajudam a criar outras classes. Os objetos do negócio e a lógica deles são independente dessas fábricas. Poderíamos usar outros padrões, como a Fábrica Simples (Simple Factory), Fábrica Abstrata (Abstract Factory), Construtor (Builder) ou um sistema padrão de criação de objetos, capazes de prover a lógica do negócio. Não importa. Uma vez que os objetos forem criados, eles podem realizar seus trabalhos.</li>
</ul>

<h2>Mostre-me o Código</h2>

<p>Aplicar o Princípio da Inversão de Dependência (DIP), em um nível arquitetural, é bem simples, se você respeitar os <a href="https://tutsplus.com/course/agile-design-patterns/">padrões de projeto ágeis</a> clássicos. Exercitá-los e exemplificá-los dentro da lógica de negócios também é bem simples e pode, até, ser bem diverto. Imaginemos uma aplicação leitora de e-books.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new PDFReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

class PDFReader {

	private $book;

	function __construct(PDFBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook {

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>Nós começamos a desenvolver nosso leitor eletrônico como um leitor de PDF. Até agora, tudo bem. Nós temos uma classe <code>PDFReader</code> usando uma classe <code>PDFBook</code>. O método <code>read()</code> do leitor, incumbe o método <code>read()</code> do livro. Nós verificamos isso, usando uma expressão regular para buscar a chave na cadeia de caracteres retornada pelo método <code>reader()</code> da classe <code>PDFBook</code>.</p>

<p>Por favor, tenha em mente que isso não passa de um exemplo. Nós não implementaremos a lógica de leitura de arquivos PDF ou de outros formatos. É por isso que nossos testes, simplesmente, verificarão algumas cadeias de caracteres básicas. Se fôssemos criar uma aplicação de verdade, a única diferença seria como testaríamos os diferentes formatos de arquivos. A estrutura de dependência seria bem parecida com o do nosso exemplo.</p>

<figure>
<img width="600" alt="pdfreader-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/pdfreader-pdfbook.png" height="89"><br>
</figure>

<p>Ter um leitor de PDF usando um livro em PDF pode parecer uma solução bacana para uma aplicação limitada. Se nosso escopo fosse criar, apenas, um leitor de PDF e nada mais, até que seria uma solução aceitável. Mas, queremos criar um leitor genérico, capaz de suportar diversos formatos, entre eles, o PDF, que é o primeiro a implementarmos. Renomeemos nossa classe leitora.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

class EBookReader {

	private $book;

	function __construct(PDFBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook {

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>Renomear não tem qualquer efeitos colaterais. Os testes ainda passam.</p>

<p>Testing started at 1:04 PM ...<br>
PHPUnit 3.7.28 by Sebastian Bergmann.<br>
Time: 13 ms, Memory: 2.50Mb<br>
OK (1 test, 1 assertion)<br>
Process finished with exit code 0</p>

<p>Mas isso gera um efeito sério de projeto.</p>

<figure>
<img width="600" alt="ebookreader-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/ebookreader-pdfbook.png" height="89"><br>
</figure>

<p>Nosso leitor tornou-se muito mais abstrato. Nós temos uma classe <code>EBookReader</code> genérica que usa um tipo específico de livro, <code>PDFBook</code>. A abstração depende do detalhe. O fato que nosso livro é do tipo PDF deveria ser só um detalhe e, nada deveria depender disso.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

interface EBook {
	function read();
}

class EBookReader {

	private $book;

	function __construct(EBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook implements EBook{

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>A solução mais comum e frequente para inverter a dependência é introduzir um módulo mais abstrato em nosso projeto. "O elemento mais abstrato da POO é a Interface. Assim, qualquer outra classe pode depender de uma interface e, ainda assim, respeitar o DIP".</p>

<p>Nós criamos uma interface <em>para nosso leitor</em>. Chamamos a interface de <code>EBook</code> e ela representa as necessidades de uma classe <code>EBookReader</code>. Esse é um resultado direto do respeito ao <a href="http://dev.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Princípio da Segregação de Interfaces (ISP)</a> que promove a ideia que as interfaces devem refletir as necessidades dos clientes. As interfaces pertencem aos clientes e, assim, elas são nomeadas para refletir os tipos e objetos que os clientes precisam, e eles conterão os métodos que os clientes querem. É natural e esperado que uma classe <code>EBookReader</code> use a interface <code>EBooks</code> e tenha um método <code>read()</code>.</p>

<figure>
<img width="600" alt="ebookreader-ebookinterface-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/ebookreader-ebookinterface-pdfbook.png" height="246"><br>
</figure>

<p>Ao invés de uma única dependência, temos duas dependências, agora.</p>

<ul>
<li>A primeira dependência vai da classe <code>EBookReader</code> para a interface <code>EBook</code>, e é do tipo de uso. <code>EBookReader</code> usa <code>EBooks</code>.</li>
<li>A segunda dependência é diferente. Ela vai da classe <code>PDFBook</code> para a interface <code>EBook</code>, mas é do tipo implementação. Uma classe <code>PDFBook</code> é um tipo particular da interface <code>EBook</code>, e, assim, implementa essa interface para satisfazer as necessidades do cliente.</li>
</ul>

<p>Sem supresas, essa solução também permite usar diferentes tipos de ebooks em nosso leitor. A única condição é satisfazer a interface <code>EBook</code> e implementá-la.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

	function testItCanReadAMobiBook() {
		$b = new MobiBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/mobi book/', $r-&gt;read());
	}

}

interface EBook {
	function read();
}

class EBookReader {

	private $book;

	function __construct(EBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook implements EBook {

	function read() {
		return "reading a pdf book.";
	}
}

class MobiBook implements EBook {

	function read() {
		return "reading a mobi book.";
	}
}</pre>

<p>Que, em troca, leva-nos ao <a href="http://dev.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600">Princípio do Aberto para Expansão, Fechado para Modificação</a>, e, assim, fechando o ciclo.</p>

<p>O Princípio da Inversão da Dependência é aquele que nos leva, ou ajuda, a respeitar todos os outros princípios. Respeitando o DIP leva a:</p>

<ul>
<li>Um respeito, quase forçado, do OCP.</li>
<li>Separação de responsabilidades.</li>
<li>Usar subtipos corretamente.</li>
<li>A oportunidade da segregação de suas interfaces.</li>
</ul>

<h2>Considerãções Finais</h2>

<p>É isso. Terminamos. Todos os tutoriais sobre os princípios SOLID estão completos. Para mim, descobrir esses princípios e implementar projetos tendo-os em mente, levou a uma grande mudança. Mudei completamente a forma como pensava sobre os projetos e suas arquiteturas e, posso dizer que, desde então, todos os projetos que trabalho, estão, exponecialmente, mais fáceis de entender e administrar.</p>

<p>Considero os princípios SOLID um dos conceitos mais essenciais do mundo dos projetos orientados a objeto. Esses conceitos devem nos guiar a criar códigos melhores e facilitar nossa vida de programadores. Código bem projetado é mais fácil para programadores entenderem. Computadores são espertos, eles podem entender códigos, independente de sua complexidade. Seres humanos, por outro lado, tem um limite de coisas que podem se manter focados. Mais especificamente, a quantidade de coisas que os humanos podem se focar é <a href="http://www.musanim.com/miller1956/">O Número Mágico Sete, Mais ou Menos Dois</a>.</p>

<p>Devemos buscar ter códigos estruturados, baseados nesses números, e há inúmeras técnicas que podem nos ajudar nisso. Funções com um máximo de quatro linhas para seu tamanho (cinco, se considerarmos a linha de definição da função) permitem que elas caibam, completamente, em nossa mente. Identações não passando de cinco níveis. Classes com, no máximo, nove métodos. Padrões de Projeto que usem entre quatro e nove classes. O nosso projeto de alto nível, nos esquemas acima, usa quatro ou cinco conceitos. Há cinco princípios SOLID, cada um requerendo de cinco a nove sub-conceitos/módulos/classes para serem exemplificados. O tamanho ideal de uma equipe de programadores é entre cinco e nove. O número ideal de equipes em uma empresa é de cinco a nova.</p>

<p>As you can see, the magical number seven, plus or minus two is all around us, so why should your code be different?</p>
