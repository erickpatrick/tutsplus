<h1>Princípos SOLID Parte 4 - Princípio da Inversão de Dependência</h1>

<p><a href="http://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Responsabilidade Única (SRP - Single Responsability)</a>, <a href="http://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600">Aberto para Expansão, Fechado para Modificações (Open/Close)</a>, <a href="http://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Substituição de Liskov (Liskov's Substitution), Segregação de Interface (Interface Segregation);</a> e <em>Inversão de Dependência (Dependency Inversion)</em>. Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<p>Não seria justo dizer que qualquer um dos princípios SOLID fosse mais importante que os outros. Contudo, é bem provável que nenhum dos outros princípios tenha efeito tão imediato e profundo em seu código quanto o Princípio da Inversão de Dependência (Dependency Inversion Principle - DIP). Se você acha os outros princípios difíceis de entender e aplicar, comece com esse daqui e aplique os outros princípios nos códigos que respeitem o DIP.</p>

<h2>Definição</h2>

<blockquote><p>A. Módulos de alto nível não deveriam depender em módulos de baixo nível. Ambos deveriam depender de abstrações.<br>
B. Abstrações não deveriam depender de detalhes. Detalhes devem depender de abstrações.</p>
</blockquote>

<p>Esse princípio foi definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e depois na versão em C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, e é o último dos cinco princípios ágeis SOLID.</p>

<h2>DIP no Mundo Real</h2>

<p>Antes de começarmos a codificar algo, quero contar-lhes uma história. Lá na Syneto, não fomos, sempre, cuidados com os códigos que criamos. Alguns anos atrás, sabíamos menos e, embora puséssemos o melhor de nós, nem todos nossos projetos eram legais. Nós fomos ao inferno e voltamos, e aprendemos algumas coisas, na tentativa e erro.</p>

<p>Os princípios SOLID e a clara arquitetura do Tio Bob (Robert C. Martin) mudaram nossa situação, e transformaram a maneira como codificamos, de tal forma, que é difícil de descrever. Tentarei explicar, de forma simples, algumas decisões arquiteturais impostas pelo DIP que tiveram um grande impacto em nossos projetos.</p>

<p>A maioria dos projetos web contém três tecnologias principais: HTML, PHP, e SQL. As versões específicas dessas tecnologias ou o tipo da implementação SQL que usamos, são irrelevantes. O ponto é, a informação em um formulário HTML deve acabar, de uma forma ou de outra, no banco de dados. A "cola" necessária entre os dois, pode ser dado pelo PHP.</p>

<p>O que é preciso entender dessa situação, é como essas três tecnologias representam tão bem três camadas arquiteturais diferentes: interface do usuário, lógica de negócios e persistência. Nós trataremos sobre as implicações dessas três camadas em um minuto. Por hora, foquemos numa forma esquisita e frequentente vista para fazer essas tecnologias trabalharem juntas.</p>

<p>Já vi diversos projetos que usam código SQL em um script PHP, dentro de um arquivo HTML, ou, ainda, códigos PHP imprimindo páginas e mais páginas de HTML, interpretando, diretamente, variáveis globais de <code>$_GET</code> ou <code>$_POST</code>. Mas, por que isso é ruim?</p>

<figure>
<img width="600" alt="html-php-sql-cross-dependencies" src="http://cdn.tutsplus.com/net/uploads/2014/02/html-php-sql-cross-dependencies.png" height="423"><br>
</figure>

<p>As imagens acima representam uma versão bem crua do que descrevemos no parágrafo anterior. As setas representam várias dependências e, podemos concluir que, basicamente, tudo depende tudo. Se precisamos mudar uma tabela da base de dados, talvez tenhamos de alterar até algum arquivo HTML. Ou, se mudarmos algum campo de formulário no HTML, nós talvez precisemos mudar o nome de alguma coluna em alguma instrução SQL. Ou, se aprendermos algum outro esquema, talvez precisemos mudar nosso código PHP se o HTML mudar, ou, em casos bem ruins, se geramos o HTML a partir de um arquivo PHP, é certo que tenhamos de modificar o código PHP para modificar o HTML. Então, não há dúvidas, as dependências estão ziguezagueando entre as clsses e módulos. Mas, não acaba aí. Você pode ter procedimentos armazenados: Código PHP em tabelas SQL.</p>

<figure>
<img width="600" alt="html-php-sql-stored-procedures" src="http://cdn.tutsplus.com/net/uploads/2014/02/html-php-sql-stored-procedures.png" height="503"><br>
</figure>

<p>No esquema acima, as consultas SQL na base de dados retornam código PHP gerado com os dados vindos das tabelas. Essas funções ou classes PHP executam outras consultas SQL que retornam outros códigos PHP, e o ciclo continua até, finalmente, toda a informação obtida é retornada... provavelmente para a Interface do Usuário.</p>

<p>Sei que isso pode parecer terrível para a maioria de vocês, mas, se você não trabalhou com um projeto inventado e implementado dessa forma, você, provavelmente, irá em algum projeto futuro. A maioria dos projetos existentes, independente da linguagem de programação usada, foram escritos com antigos princípios em mente, por programadores que não se importavam ou não sabiam como fazer melhor. Se você está lendo esses tutoriais, você, certamente, está um nível acima. Você está pronto ou preparando-se para respeitar seu trabalho, abraçar sua arte e fazer mais e melhor.</p>

<p>A outra opção é repetir os erros de seus predecessores cometeram e viver com as consequências. Lá na Syneto, depois que um de nossos projetos alcançou um estado de uma manutenção quase que impraticável, devido a sua arquitetura antiga e interdependente, tivemos de abandoná-la para sempre, nós decidimos que não queríamos seguir aquele caminho, novamente. Desde então, nós buscamos uma arquitetura clara, que respeita os princípios SOLID e, de forma mais importante, o Princípio da Inversão de Dependência.</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2014/02/HighLevelDesign.png" height="388"><br>
</figure>

<p>O que é tão maravilhos sobre essa arquitetura é como as dependências estão apontando:</p>

<ul>
<li>A interface do usuário (na maioria dos casos, uma *framework* MVC) ou qualquer outro mecanismo de entrega que exista em seu projeto, dependerá da lógica de negócio. A lógica de negócio é bem abstrata. A interface do usuário é bem concreta. A interface do usuário é apenas um detalhe no projeto e também é bastante volátil. Nada deveria depender da interface do usuário, nada deveria depender da sua *framework* MVC.</li>
<li>Outra observação importante que podemos fazer é que a persistência, a base de dados, seu MySQL ou PostgreSQL, depende da lógica de negócio. Sua lógica de negócio é agnóstica em relação a base de dados. Isso permite troca o método de persistência quando e como quiser. Se, amanhã, você quiser mudar do MySQL/PostgreSQL para arquivos de texto, você pode fazer isso. Claro, você terá de implementar uma camada específica de persistência para esse novo método, mas não precisará mudar um única linha da sua lógica de negócio. Há uma explicação muito mais detalhada sobre persistência no tutorial <a href="http://code.tutsplus.com/tutorials/evolving-toward-a-persistence-layer--net-27138">Evolving Toward a Persistence Layer</a>.</li>
<li>Finalmente, do lado direito da lógica de negócios, na parte externa, nós temos todas as classes que criam as classes para a lógica de negócios. Essas são "fábricas" e classes criadas pelo ponto de entrada da aplicação. Muitas pessoas acreditam que essas classes pertencem à lógica de negócios, mas, enquanto criarem objetos de negócio, o único motivo de existência deles é esse. Elas são classes que nos ajudam a criar outras classes. Os objetos do negócio e a lógica deles são independente dessas fábricas. Poderíamos usar outros padrões, como a Fábrica Simples (Simple Factory), Fábrica Abstrata (Abstract Factory), Construtor (Builder) ou um sistema padrão de criação de objetos, capazes de prover a lógica do negócio. Não importa. Uma vez que os objetos forem criados, eles podem realizar seus trabalhos.</li>
</ul>

<h2>Mostre-me o Código</h2>

<p>Aplicar o Princípio da Inversão de Dependência (DIP), em um nível arquitetural, é bem simples, se você respeitar os <a href="https://tutsplus.com/course/agile-design-patterns/">padrões de projeto ágeis</a> clássicos. Exercitá-los e exemplificá-los dentro da lógica de negócios também é bem simples e pode, até, ser bem diverto. Imaginemos uma aplicação leitora de e-books.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new PDFReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

class PDFReader {

	private $book;

	function __construct(PDFBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook {

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>Nós começamos a desenvolver nosso leitor eletrônico como um leitor de PDF. Até agora, tudo bem. Nós temos uma classe <code>PDFReader</code> usando uma classe <code>PDFBook</code>. O método <code>read()</code> do leitor, incumbe o método <code>read()</code> do livro. Nós verificamos isso, usando uma expressão regular para buscar a chave na cadeia de caracteres retornada pelo método <code>reader()</code> da classe <code>PDFBook</code>.</p>

<p>Please bear in mind that this is just an example. We will not implement the reading logic of PDF files or other file formats. That's why our tests will just simply check for some basic strings. If we were to write the real application, the only difference would be how we test the different file formats. The dependency structure would be very similar to our example.</p>

<figure>
<img width="600" alt="pdfreader-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/pdfreader-pdfbook.png" height="89"><br>
</figure>

<p>Having a PDF reader using a PDF book may be a sound solution for a limited application. If our scope was to write a PDF reader and nothing more, it would actually be an acceptable solution. But we want to write a generic e-book reader, supporting several formats, amongst which our first implemented version PDF. Let's rename our reader class.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

class EBookReader {

	private $book;

	function __construct(PDFBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook {

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>Renaming had no functional counter effects. The tests are still passing.</p>

<p>Testing started at 1:04 PM ...<br>
PHPUnit 3.7.28 by Sebastian Bergmann.<br>
Time: 13 ms, Memory: 2.50Mb<br>
OK (1 test, 1 assertion)<br>
Process finished with exit code 0</p>

<p>But it has a serious design effect.</p>

<figure>
<img width="600" alt="ebookreader-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/ebookreader-pdfbook.png" height="89"><br>
</figure>

<p>Our reader became much more abstract. Much more general. We have a generic <code>EBookReader</code> that uses a very specific book type, <code>PDFBook</code>. An abstraction depends on a detail. The fact that our book is of type PDF should only be a detail, and no one should depend on it.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

interface EBook {
	function read();
}

class EBookReader {

	private $book;

	function __construct(EBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook implements EBook{

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>The most common, and most frequently used solution to invert the dependency is to introduce a more abstract module in our design. "The most abstract element in OOP is an Interface. Thus, any other class can depend on an Interface and still respect DIP".</p>

<p>We created an interface <em>for our reader</em>. The interface is called <code>EBook</code> and represents the needs of the <code>EBookReader</code>. This is a direct result of respecting the <a href="http://dev.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Interface Segregation Principle (ISP)</a> which promotes the idea that interfaces should reflect the needs of the clients. Interfaces belong to the clients, and thus they are named to reflect the types and objects the clients need and they will contain methods the clients wants to use. It is only natural for an <code>EBookReader</code> to use <code>EBooks</code> and have a <code>read()</code> method.</p>

<figure>
<img width="600" alt="ebookreader-ebookinterface-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/ebookreader-ebookinterface-pdfbook.png" height="246"><br>
</figure>

<p>Instead of a single dependency, we have two dependencies now.</p>

<ul>
<li>The first dependency points from <code>EBookReader</code> toward the <code>EBook</code> interface and it is of type usage. <code>EBookReader</code> uses <code>EBooks</code>.</li>
<li>The second dependency is different. It points from <code>PDFBook</code> toward the same <code>EBook</code> interface but it is of type implementation. A <code>PDFBook</code> is just a particular form of <code>EBook</code>, and thus implements that interface to satisfy the client's needs.</li>
</ul>

<p>Unsurprisingly, this solution also allows us to plug in different types of ebooks into our reader. The single condition for all these books is to satisfy the <code>EBook</code> interface and implement it.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

	function testItCanReadAMobiBook() {
		$b = new MobiBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/mobi book/', $r-&gt;read());
	}

}

interface EBook {
	function read();
}

class EBookReader {

	private $book;

	function __construct(EBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook implements EBook {

	function read() {
		return "reading a pdf book.";
	}
}

class MobiBook implements EBook {

	function read() {
		return "reading a mobi book.";
	}
}</pre>

<p>Which in turn leads us to <a href="http://dev.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600">The Open/Closed Principle</a>, and the circle is closed.</p>

<p>The Dependency Inversion Principle is one that leads or helps us respect all the other principles. Respecting DIP will:</p>

<ul>
<li>Almost force you into respecting OCP.</li>
<li>Allow you to separate responsibilities.</li>
<li>Make you correctly use subtyping.</li>
<li>Offer you the opportunity to segregate your interfaces.</li>
</ul>

<h2>Final Thoughts</h2>

<p>That's it. We are done. All tutorials about the SOLID principles are complete. For me, personally, discovering these principles and implementing projects with them in mind was a huge change. I completely changed the way I think about design and architecture and I can say since then all the projects I work on are exponentially easier to manage and understand.</p>

<p>I consider the SOLID principles one of the most essential concepts of object-oriented design. These concepts that must guide us in making our code better and our life as programmers much much easier. Well-designed code is easier for programmers to understand. Computers are smart, they can understand code regardless of its complexity. Human beings on the other hand have a limited number of things they can keep in their active, focused mind. More specifically, the number of such things is <a href="http://www.musanim.com/miller1956/">The Magical Number Seven, Plus or Minus Two</a>.</p>

<p>We should strive to have our code structured around these numbers and there are several techniques that help us do so. Functions with a maximum of four lines in length (five with the definition line included) so that they can all fit at once within our mind. Indentations not passing five levels deep. Classes with no more than nine methods. Design patterns that usually use a number of five to nine classes. Our high level design in the schemas above uses four to five concepts. There are five SOLID principles, each requiring five to nine sub-concepts/modules/classes to be exemplified. The ideal size of a programming team is between five and nine. The ideal number of teams in a company is between five and nine.</p>

<p>As you can see, the magical number seven, plus or minus two is all around us, so why should your code be different?</p>
