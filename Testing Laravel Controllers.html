<h1>Testando Controladores no Laravel</h1>

<p>Testar controladores não é das tarefas mais fáceis. Bem, deixe-me reformular essa frase: Testar controladores é fácil, o problema, pelo menos inicialmente, é <em>o que se deve</em> testar</p>

<p>Um teste de controlador deve verificar textos em uma página? Ele deveria comunicar-se com a base de dados? Deve garantir que certas variáveis existem nas visões? Se essa é sua primeira vez com testes, todos esses pontos podem ser bem confusos! Deixe-me ajudá-lo.</p>


<blockquote>
<p>Testes de controladores devem verificar respostas enviadas; garantir que a chamada aos corretos métodos de acesso às bases de dados; e confirmar que as variáveis de instância corretas foram enviadas para a visão.</p>
</blockquote>

<p>O processo de testar um controlador pode ser dividido em três partes:</p>

<ul><li><strong>Isolamento:</strong> Simule todas as dependências (exceto, talvez a classe <code>View</code>).</li>
<li><strong>Chamada:</strong> Chame o método desejado do controlador.</li>
<li><strong>Garantia:</strong> Execute as declarações de teste, verificando se tudo foi feito corretamente.</li>
</ul>

<h2>O "Hello World" dos Testes de Controladores</h2>

<p>A melhor maneira de aprender algo é através de exemplos. Eis o equivalente a um "<em>hello world</em>" para testes de controladores no Laravel.</p>

<pre class="brush: php">
&lt;?php

# app/tests/controllers/PostsControllerTest.php

class PostsControllerTest extends TestCase {

public function testIndex()
{
    $this-&gt;client-&gt;request('GET', 'posts');
}

}</pre>

<p>O Laravel lança mão de vários componentes do Symfony para facilitar o processo de testar rotas e visões, incluindo o HttpKernel, DomCrawler e BrowserKit. É por isso que é importante seus testes com PHPUnit estendam a classe <code>TestCase</code>, não a classe <code>PHPUnit\_Framework\_TestCase</code>. Não se preocupe, a classe que o Laravel provê estende a classe original do PHPUnit. Além disso, ajuda a preparar sua aplicação em Laravel para os testes, além de prover uma variedade de métodos que auxiliarão em seus testes e que seria bom você utilizá-los. Nós falaremos mais sobre eles daqui a pouco.</p>

<p>No trecho de código acima, nós fazemos uma requisição <code>GET</code> para posts <code>/posts</code> ou <code>localhost:8000/posts</code>. Assumindo que esse código é adicionado a uma instalação recém criada do Laravel, o Symfony lançará uma exceção do tipo <code>NotFoundHttpException</code>. Se estiver codificando junto, vá até a linha de comando e execute o comando <code>phpunit</code>.</p>

<pre class="brush: bash">
$ phpunit
1) PostsControllerTest::testIndex
Symfony\Component\HttpKernel\Exception\NotFoundHttpException:</pre>

<p>Traduzindo para algo que <em>humanos</em> entendam, isso, essencialmente, está dizendo: "<em>Ei, tentei chamar aquela rota, mas você não registro algo, ainda, bobo!</em>"</p>

<p>Como pode imaginar, esse tipo de requisição é tão comum, que faz sentido ter um método auxiliar. Algo como <code>$this-&gt;call()</code>. Para falar a verdade, o Laravel faz isso! Isso significa que o exemplo anterior pode ser refatorado, dessa forma:</p>

<pre class="brush: php">
#app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $this-&gt;call('GET', 'posts');
}</pre>

<h3>A Sobrecarga é sua Amiga</h3>

<p>Embora nós iremos nos ater à funcionalidade básica nesse capítulo, em meus projetos pessoais, vou além e permito a existência de métodos como <code>$this-&gt;get()</code>, <code>$this-&gt;post()</code>, etc. Graças à sobrecarga do PHP, isso só requer a adição de um único método, o qual você pode adicionar a <code>app/tests/TestCase.php</code>.</p>

<pre class="brush: php">
# app/tests/TestCase.php

public function __call($method, $args)
{
  if (in_array($method, ['get', 'post', 'put', 'patch', 'delete']))
  {
      return $this-&gt;call($method, $args[0]);
  }

  throw new BadMethodCallException;
}</pre>

<p>Agora, você já pode escrever algo como <code>$this-&gt;get('posts')</code> e obter o mesmo resultado dos dois exemplos anteriores. Mas, como disse, vamos continuar só com as funcionalidades básicas da framework, para não complicar as coisas.</p>

<p>Para fazer o teste passar, só precisamos criar a rota apropriada.</p>

<pre class="brush: php">
&lt;?php

# app/routes.php

Route::get('posts', function()
{
  return 'todos os posts';
});</pre>

<p>Executar, novamente, <code>phpunit</code> fará com que voltemos ao estado verde.</p>

<h2>As Declarações Auxiliares do Laravel</h2>

<p>Um teste que você criará bastante, é aquele que garante que o controlador passou uma variável em particular para a visão. Por exemplo, o método <code>index</code> de <code>PostsController</code> deve passar uma variável <code>$posts</code> à sua visão correspondente, certo? Dessa forma, a visão pode percorrer por todos os posts e mostrá-los na página. Esse é um teste importante de se escrever!</p>

<p>E, se isso é tão comum, mais uma vez, não faria sentido o Laravel provê declarações auxiliares para que possamos realizar essa tarefa? Claro que faria. E, claro, o Laravel provê!</p>

<p>A classe <code>Illuminate\Foundation\Testing\TestCase</code> inclui uma série de métodos que reduzem, drasticamente, a quantidade de código necessária para realizar essas declarações de testes, básicas. A lista inclui:</p>

<ul>
<li><code>assertViewHas</code></li>
<li><code>assertResponseOk</code></li>
<li><code>assertRedirectedTo</code></li>
<li><code>assertRedirectedToRoute</code></li>
<li><code>assertRedirectedToAction</code></li>
<li><code>assertSessionHas</code></li>
<li><code>assertSessionHasErrors</code></li>
</ul><p>O exemplo a seguir fazem uma requisição <code>GET /posts</code> e verificam se a visão recebe a variável <code>$posts</code>.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');
}</pre>

<blockquote>
<p><strong>Dica:</strong> Quando se trata de formatação dos testes, prefiro adicionar uma linha em branco entre a declaração do teste e o código que prepara o ambiente para o teste.</p>
</blockquote>

<p><code>assertViewHas</code> é uma espécie de "açúcar sintático" (atalho, se preferi) que inspeciona o objeto resposta - o retorno da chamada a <code>$this-&gt;call()</code> - e verifica se os dados associados à visão contem a variável <code>posts</code>.</p>

<p>Quando estiver inspecionando o objeto resposta, você tem duas alternativas.</p>

<ul>
<li><code>$response-&gt;getOriginalContent()</code>: Busca o conteúdo original ou a <code>View</code> retornada. Opcionalmente, você pode acessar a propriedade <code>original</code> diretamente, ao invés de chamar o método <code>getOriginalContent</code>.</li>
<li><code>$response-&gt;getContent()</code>: Busca o resultado renderizado. Se uma instância de <code>View</code> é retornada de uma rota, então <code>getContent()</code> será igual ao HTML resultante. Isso pode ser útil em verificações em relação a DOM, como: "<em>a visão deve conter essa string.</em>"</li>
</ul>

<p>Assumamos que a rota <code>posts</code> seja da seguinte forma:</p>

<pre class="brush: php">
&lt;?php

# app/routes.php

Route::get('posts', function()
{
  return View::make('posts.index');
});</pre>

<p>Se executarmos o <code>phpunit</code>, ele reclamará e apontará o que devemos fazer:</p>

<pre class="brush: bash">
1) PostsControllerTest::testIndex
Failed asserting that an array has the key 'posts'.</pre>

<p>O <code>phpunit</code> apontou que não conseguiu encontrar qualquer variável chamada 'posts'. Para fazer com que o teste fique verde, temos que buscar os posts e enviá-los para a visão.</p>

<pre class="brush: php">

# app/routes.php

Route::get('posts', function()
{
  $posts = Post::all();

  return View::make('posts.index', ['posts', $posts]);
});</pre>

<p>Uma coisa a se ter em mente é que, com o código que temos até agora, a única garantia que temos é que uma variável <code>$posts</code> é enviada para a visão. Ele não inspeciona o valor dessa variável. O método de teste <code>assertViewHas</code>, opcionalmente, aceita um segundo parâmetro contendo o valro esperado da variável, para, assim como atestar a existência da variável, poder verificar o valor dela.</p>

<pre class="brush: php">

# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts', 'foo');
}</pre>

<p>Com essa modificação no código, a menos que a variável tenha uma variável <code>$posts</code> com valor igual a <code>foo</code>, o teste falhará. Nessa situação, porém, é melhor não especificarmos um valor em si, mas declararmos que o valor será uma instância da classe <code>Illuminate\Database\Eloquent\Collection</code> do Laravel. Como podemos fazer isso? O PHPUnit nos fornece um método útil, chamado <code>assertInstanceOf</code>.</p>

<pre class="brush: php">

# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $response = $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');

  // getData() retorna todas as variáveis associadas à resposta.
  $posts = $response-&gt;original-&gt;getData()['posts'];

  $this-&gt;assertInstanceOf('Illuminate\Database\Eloquent\Collection', $posts);
}</pre>

<p>Com essa modificação, declaramos que o controlador <strong>deve</strong> enviar a variável <code>$posts</code> - uma instância da classe <code>Illuminate\Database\Eloquent\Collection</code> - para a visão. Excelente.</p>

<h2>Simulando a Base de Dados</h2>

<p>Há um problema bastante evidente com os nossos testes, até agora. Você percebeu?</p>

<blockquote>
<p>Para cada teste, uma consulta SQL tem sido executada e acessado a base de dados. Embora isso seja útil em alguns tipos de testes (testes de aceitação e integração), para testes básicos dos controladores, isso só servirá para diminuir a performance.</p>
</blockquote>

<p>Eu já devo ter encravado isso no seu cérebro de tanto falar (nota: esse texto faz parte do livro <em>Laravel Testing Decoded</em>, do próprio Jeffrey Way). Não estamos interessados em testar as capacidades do Eloquente em buscar os registros da base de dados. Ele tem seus próprios testes. Taylor (Otwell, criador da framework) sabe que ele funciona! Não percamos tempo nem poder de processamento repetindo todos esses testes.</p>

<p>Ao invés disso, é melhor simular a base de dados e verificar se os métodos apropriados são chamados com seus respectivos argumentos necessários. Ou, em outras palavras, nós queremos garantir que a chamada <code>Post::all()</code> nunca seja disparada de verdade nem acessa a base de dados. Nós sabemos que ela funciona, logo não precisa de testes.</p>

<p>Essa seção dependerá bastante da biblioteca Mockery. Por favor, revise esse capítulo do <a href="http://leanpub.com/laravel-testing-decoded">meu livro</a>, se você ainda não a conhece.</p>

<h3>Refatoração Necessária</h3>

<p>Infelizmente, até agora, nós estruturamos nosso código de uma forma que, virtualmente, é impossível de testar.</p>

<pre class="brush: php">
# app/routes.php

Route::get('posts', function()
{
  // Oh, não! Não podemos testar isso!!
  $posts = Post::all();

  return View::make('posts.index')
      -&gt;with('posts', $posts);
});</pre>

<p>É, exatamente, por isso que é considerado má prática inserir chamadas ao Eloquent em seus controladores. Não confunda com as <em>facade</em> do Laravel, que são testáveis e podem ser substituídas por simulacros (<code>Queue::shouldReceive()</code>), com seus modelos Eloquent. A solução é injetar a camada da base de dados no controlador através do método construtor. Isso requer refatoração.</p>

<blockquote>
<p><strong>Atenção:</strong> Manter a lógica de um projeto dentro das rotas é útil qual ele é pequeno ou quando se quer criar uma API, mas isso torna a testabilidade do projeto incrivelmente difícil. Para aplicações de tamanhos consideráveis, use controladores.</p>
</blockquote>

<p>Registremos um novo recurso, substituindo a rota <code>posts</code> com:</p>

<pre class="brush: php">
# app/routes.php

Route::resource('posts', 'PostsController');</pre>

<p>...e criemos o controlador inteligente utilizando o Artisan.</p>

<pre class="brush: bash">
$ php artisan controller:make PostsController
Controller created successfully!</pre>

<p>Agora, ao invés de referencia o modelo <code>Post</code> diretamente, poderemos injetá-lo através do construtor do controlador. Eis um exemplo condensado, omitindo todos os métodos restful, exceto aquele que estamos interessados em testar.</p>

<pre class="brush: php">
&lt;?php

# app/controllers/PostsController.php

class PostsController extends BaseController {

protected $post;

public function __construct(Post $post)
{
    $this-&gt;post = $post;
}

public function index()
{
    $posts = $this-&gt;post-&gt;all();

    return View::make('posts.index')
        -&gt;with('posts', $posts);
}

}</pre>

<blockquote>
<p>Por favor, lembre-se que é melhor induzir o tipo de uma interface ao invés de referenciar diretamente um modelo do Eloquente. Mas, cada coisa a seu tempo, não é?</p>
</blockquote>

<p>Essa é uma maneira muito melhor de estruturar seu código. Uma vez o modelo sendo injetado, como o está agora, temos a capacidade de substituí-lo por uma versão simulada para testes. Veja um exemplo de como fazer isso:</p>

<pre class="brush: php">
&lt;?php

# app/tests/controllers/PostsControllerTest.php

class PostsControllerTest extends TestCase {

public function __construct()
{
    // Nós não temos qualquer interesse em testar o Eloquent
    $this-&gt;mock = Mockery::mock('Eloquent', 'Post');
}

public function tearDown()
{
    Mockery::close();
}

public function testIndex()
{
    $this-&gt;mock
         -&gt;shouldReceive('all')
         -&gt;once()
         -&gt;andReturn('foo');

    $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

    $this-&gt;call('GET', 'posts');

    $this-&gt;assertViewHas('posts');
}

}</pre>

<p>O principal benefício nessa reestruturação é que, agora, nucna mais será acessa desnecessariamente. Ao invés disso, ao usar a Mockery, simplesmente, verificamos se o método <code>all</code> foi chamado no modelo.</p>

<pre class="brush: php">
$this-&gt;mock
  -&gt;shouldReceive('all')
  -&gt;once();</pre>

<p>Infelizmente, se você prefere não codificar usando interfaces e preferir injetar, diretamente, o modelo <code>Post</code> no seu controlador, é preciso usar algumas artimanhas para lidar com o uso de métodos estáticos do Eloquent, os quais podem chocar com a Mockery. É por isso que criamos versões falsas, tanto da classe/modelo <code>Post</code> quanto da classe <code>Eloquent</code> no construtor de nossos testes, antes que as versões verdadeiras sejam carregadas. Dessa forma, temos caminho limpo para declarar qualquer expectativa. O lado ruim, claro, é que não podemos usar lançar mãos de qualquer método existente, através dos métodos da Mockery, como o <code>makePartial()</code>.</p>

<h3>O Recipente de Inversão de Controle</h3>

<p>O recipiente de Inversão de Controle (<em>IoC Container</em>) do Laravel facilita o processo de injeção de dependencias em suas classes. Cada vez que um controlador é requisitado, ele é resolvido direto desse recipiente. Dessa forma, quando nós precisarmos declarar que uma versão simulada de <code>Post</code> dever ser usada nos testes, nós só precisamos prover ao Laravel a instância de <code>Post</code> que deverá ser usada.</p>

<pre class="brush: php">
$this-&gt;app-&gt;instance('Post', $this-&gt;mock);</pre>

<blockquote>
<p>Imagine esse código como, "<em>Ei, Laravel, quando precisar de uma instância de <code>Post</code>, eu quero que você use essa minha versão simulada.</em>" Uma vez que a app estende a classe <code>Container</code>, temos acesso a todos os métodos do recipiente de inversão de controle, diretamente dela.</p>
</blockquote>

<p>Durante a instanciação do controlador, o Laravel faz uso das capacidade reflexivas do PHP para ler a indução de tipo usada e injetar a dependência correta para você. É isso. Você não precisa escrever uma linha de código sequer para que isso aconteça. Tudo é automatizado!</p>

<h2>Redirecionamentos</h2>

<p>Outro teste que você criará bastante é aquele que garante que o usuário é redirecionado para a localização correta, como quando depois de adicionar um novo post. Como podemos fazer isso?</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStore()
{
  $this-&gt;mock
       -&gt;shouldReceive('create')
       -&gt;once();

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  $this-&gt;assertRedirectedToRoute('posts.index');

}</pre>

<p>Assumindo que estamos seguindo o padrão restful, para adicionar um novo post, nós devemos fazer uma requisição <code>POST</code> para a coleção ou para <code>posts</code> (não confunda o método de requisição <code>POST</code> com o nome do recurso, que, nesse caso, são iguais).</p>

<pre class="brush: php">
$this-&gt;call('POST', 'posts');</pre>

<p>Então, só precisamos usar outro método auxiliar do Laravel, o <code>assertRedirectedToRoute</code>.</p>

<blockquote>
<p><strong>dica:</strong> Quando um recurso é registrado no Laravel (usando <code>Route::resource()</code>), a framework registrará, automaticamente, as rotas nomeadas necessárias. Execute <code>php artisan routes</code> se você, alguma vez, esquecer quais~os nomes dessas rotas.</p>
</blockquote>

<p>Talvez você também queria garantir que a variável superglobal <code>$_POST</code> é enviada para o método <code>create</code>. Embora não estejamos enviando um formulário de verdade, ainda assim podemos permitir isso, através do método <code>Input::replace()</code>, que nos permite preencher preencher esse array. Segue o teste modificado, que usa o método <code>with()</code> da Mockery para verificar os argumentos passados para o método referenciado por <code>shouldReceive</code>.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStore()
{
  Input::replace($input = ['title' =&gt; 'My Title']);&lt;/p&gt;

  $this-&gt;mock
       -&gt;shouldReceive('create')
       -&gt;once()
       -&gt;with($input);

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  $this-&gt;assertRedirectedToRoute('posts.index');
}</pre>

<h2>Caminhos</h2>

<p>Algo que não consideramos nesse teste foi a validação. Devemos ter dois caminhos diferentes, como resultado do método <code>store</code>, dependendo se a validação de dados passa ou não:</p>

<ol>
<li>Redirecione de volta para o formulário de "criação de post" e mostre os erros de validação.<br /></li>
<li>Redirecione para a coleção ou para a rota nomeada <code>posts.index</code>.<br /></li>
</ol>

<blockquote>
<p>As melhores práticas indicam que cada teste deve prepresentar somente um caminho em seu código.</p>
</blockquote>

<p>O primeiro caminho será para erro na validação.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStoreFails()
{
  // Prepara para a validação falhar
  Input::replace(['title' =&gt; '']);

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  // Erro na validação deve recarregar o formulário de criação de post
  $this-&gt;assertRedirectedToRoute('posts.create');

  // Os erros devem ser enviados para a visão
  $this-&gt;assertSessionHasErrors(['title']);
}</pre>

<p>O código acima declara, explicitamente, quais erros devem existir. Alternativamente, você pode emitir o argumento de <code>assertSessionHasErrors</code>, e, nesse caso, ele verificará se uma mensagem de erro foi enviada junto (traduzindo, se seu redirecionamento com Redirection inclui a chamada ao método <code>withErrors($errors)</code>).</p>

<p>Agora, o teste que lida com validação correta.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStoreSuccess()
{
  // Prepara para a validação ocorrer corretamente
  Input::replace(['title' =&gt; 'Foo Title']);&lt;/p&gt;

  $this-&gt;mock
       -&gt;shouldReceive('create')
       -&gt;once();

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  // Deve redirecionar para a coleção com uma mensagem de sucesso
  $this-&gt;assertRedirectedToRoute('posts.index', ['flash']);
}</pre>

<p>O código produção de um possível aplicativo que valide esses dois testes seria mais ou menos assim:</p>

<pre class="brush: php">
# app/controllers/PostsController.php

public function store()
{
  $input = Input::all();

  // Nós executaremos a validação no controlador por conveniência
  // Você deveria exportar isso para um modelo ou serviço
  $v = Validator::make($input, ['title' =&gt; 'required']);

  if ($v-&gt;fails())
  {
      return Redirect::route('posts.create')
          -&gt;withInput()
          -&gt;withErrors($v-&gt;messages());
  }

  $this-&gt;post-&gt;create($input);

  return Redirect::route('posts.index')
      -&gt;with('flash', 'Seu post foi criado');
}</pre>

<p>Você percebeu como o <code>Validator</code> foi colocado dentro do controlador? Geralmente, recomendamos que você abstraia esse trecho em um serviço. Dessa forma, você pode testar a validação de forma isolada, longe dos controladores e rotas. No entanto, deixemos as coisas como estão, para facilitar. Algo que você tem de ter em mente é que não estamos simulando a classe <code>Validator</code>, embora você, certamente, possa faze-lo. Como essa classe é uma <em>facade</em>, ela pode, facilmente, ser substituida por uma versão simulada, através do método <code>shouldReceive</code> da classe Facade, sem nos preocuparmos em injetar uma instância através do construtor. Vitória!</p>

<pre class="brush: php">
# app/controllers/PostsController.php

Validator::shouldReceive('make')
  -&gt;once()
  -&gt;andReturn(Mockery::mock(['fails' =&gt; 'true']));</pre>

<p>De tempos em tempos, você descobrirá ue um método que precisa ser simulado deve retornar um objeto: o próprio objeto. Felizmente, com Mockery, isso é muito fácil: só precisamos criar uma simulação anônima e passar um array, contendo o nome do método e o valor de resposta, respectivamente. Dessa forma:</p>

<pre class="brush: php">
Mockery::mock(['fails' =&gt; 'true'])</pre>

<p>Isso preparará um objeto com um método <code>fails()</code> que retorna<code>true</code>.</p>

<h2>Respositórios</h2>

<p>Para permitir flexibilidade total, ao invés de criarmos um link direto entre o controlador e um ORM, como o Eloquent, é melhor codificarmos usando interfaces. A vantagem em seguir essa abordagem é que, se precisar substituir o Eloquent por, digamos, Mongo ou Redis, poderá fazê-lo através da alteração de uma única linha de código. E o que é melhor: o controlador não precisa ser alterado.</p>

<blockquote>
<p>Repositórios representando a camada de acesso aos dados da sua aplicação.</p>
</blockquote>

<p>Como será que é uma interface para administrar a camada de base de dados de um<code>Post</code>? O código a seguir deve dar uma ideia.</p>

<pre class="brush: php">
&lt;?php

# app/repositories/PostRepositoryInterface.php

interface PostRepositoryInterface {

  public function all();

  public function find($id);

  public function create($input);

}</pre>

<p>Obviamente, podemos adicionar outras coisas, mas nós adicionamos o mínimo necessário para nossa demonstração: <code>all</code>, <code>find</code>, and <code>create</code>. Perceba que as interfaces de repositórios estão salvas no diretório <code>app/repositories</code>. Como esse diretório não é carregado automaticamente, precisamos atualizar nosso arquivo <code>composer.json</code> para que a aplicação possa referenciá-lo.</p>

<pre class="brush: js">
// composer.json

"autoload": {
"classmap": [
  // ....
  "app/repositories"
]
}</pre>

<blockquote>
<p>Quando uma nova classe for adicionada a esse diretório, não esqueça de executar <code>composer dump-autoload -o</code>. O parâmetro <code>-o</code>, (<em>optimize</em>) é opcional, mas sempre deve ser utilizado, uma vez que é uma boa prática.</p>
</blockquote>

<p>Se você tentar injetar essa interface em seu controlador, o Laravel reclamará com você, lançando um erro. Vá em frente, tente por conta própria e veja. Eis uma versão modificada do <code>PostController</code>, atualizada para injetar a interface ao invés de um modelo Eloquent do tipo <code>Post</code>.</p>

<pre class="brush: php">
&lt;?php

# app/controllers/PostsController.php

use Repositories\PostRepositoryInterface as Post;

class PostsController extends BaseController {

  protected $post;

  public function __construct(Post $post)
  {
      $this-&gt;post = $post;
  }

  public function index()
  {
      $posts = $this-&gt;post-&gt;all();

      return View::make('posts.index', ['posts' =&gt; $posts]);
  }

}</pre>

<p>Se você executar o servidor e visualizar o resultado, se deparará com a temida (mas, bonita) página de erro "Whoops", informando que "<em>PostRepositoryInterface is not instantiable.</em>" (em português: "PostRepositoryInterface não é instanciável").</p>

<figure class="tutorial_image"><img src="http://cdn.tutsplus.com/net/uploads/2013/04/instantiable.jpg" data-original-url="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/04/instantiable.jpg" alt="Not Instantiable" /><br /></figure>

<p>Se você parar para analisar, ficará claro o porque da framework reclamar. Laravel é inteligente, mas não lê mentes. Ela precisa saber qual a implementação da interface ela precisa usar em seu controlador.</p>

<p>Por hora, adicionaremos essa ligação no arquivo<code>app/routes.php</code>. Futuramente, lançaremos mão dos provedores de serviços para guardar esse tipo de código.</p>

<pre class="brush: php">
# app/routes.php

App::bind(
  'Repositories\PostRepositoryInterface',
  'Repositories\EloquentPostRepository'
);</pre>

<p>Essa chamada de método pode ser verbalizada como:, "<em>Laravel, querido, quando precisar de uma instância de <code>PostRepositoryInterface</code>, quero que use a <code>EloquentPostRepository</code>.</em>"</p>

<p><code>app/repositories/EloquentPostRepository</code> será um invólucro usando o Eloquent que implementará a <code>PostRepositoryInterface</code>. Dessa forma, não estamos restringindo a API (ou qualquer outra implementação) ao uso da versão da Eloquent. Podemos nomear os métodos como quisermos.</p>

<pre class="brush: php">
&lt;?php namespace Repositories;

# app/repositories/EloquentPostRepository.php

use Repositories\PostRepositoryInterface;
use Post;

class EloquentPostRepository implements PostRepositoryInterface {

public function all()
{
    return Post::all();
}

public function find($id)
{
    return Post::find($id);
}

public function create($input)
{
    return Post::create($input);
}

}</pre>

<blockquote>
<p>Alguns argumentam que o modelo <code>Post</code> deveria ser injetado nessa implementação para os propósitos dos testes. Se você concordar com isso, simplesmente injete-o através do construtor, como normalmente.</p>
</blockquote>

<p>E é isso tudo que precisa ser feito! Atualize seu navegador e veja como tudo voltou ao normal. A diferença é que, agora, sua aplicação está muito melhor estruturada e os controladores não estão mais ligados ao Eloquent.</p>

<p>Imaginemos que, daqui alguns meses, seu chefe diga para trocar sua implementação com Eloquent por uma que implemente com Redis. Bem, já que você estruturou sua aplicação de uma maneira à prova de mudanças, você só precisa criar a nova implementação <code>app/repositories/RedisPostRepository</code>:</p>

<pre class="brush: php">
&lt;?php namespace Repositories;

# app/repositories/RedisPostRepository.php

use Repositories\PostRepositoryInterface;

class RedisPostRepository implements PostRepositoryInterface {

public function all()
{
    // Retorne tudo usando Redis
}

public function find($id)
{
    // Retorne um item usando Redis
}

public function create($input)
{
    // Retorne a resposta do método crete usando Redis
}

}</pre>

<p>E atualizar a ligação:</p>

<pre class="brush: php">
# app/routes.php

App::bind(
  'Repositories\PostRepositoryInterface',
  'Repositories\RedisPostRepository'
);</pre>

<p>Instantanemanete, você estará usando Redis em seu controlador. Percebeu como o controlador <code>app/controllers/PostsController.php</code> não foi modificado? Aí que está a beleza da coisa toda!</p>

<h2>Estrutura</h2>

<p>Até agora, nessa lição, não temos estruturado muito bem nosso projeto. Ligações de injeção de dependência no arquivo <code>routes.php</code>? Todos os respositórios agrupados em um único diretório? Claro, isso pode funcionar no começo, mas, rapidamente, será perceptível que isso não é escalável.</p>

<p>Na parte final desse artigo, nós tornaremos nosso código compatível com PSR, e lançaremos mão de provedores de serviço para registrar quaisquer ligações necessárias em nossa aplicação.</p>

<blockquote>
<p>PSR-0 define o requerimentos obrigatórios para que haja interoperabilidade de autocarregamento de arquivos.</p>
</blockquote>

<p>Um carregador PSR-0 pode ser registrado com o Composer, através do objeto <code>psr-0</code>.</p>

<pre class="brush: js">
// composer.json

"autoload": {
  "psr-0": {
      "Way": "app/lib/"
  }
}</pre>

<p>A sintaxe é meiot confusa, no início. Para mim, com certeza foi. Uma maneira simples de entender a linha <code>"Way": "app/lib/"</code> é pensar mais ou menos assim: "<em>O diretório raiz para o <strong>namespace</strong> <code>Way</code> está localizado em <code>app/lib</code></em>". Claro, substitua meu sobrenome pelo nome do seu projeto. A esturtura de diretórios que combinará com o que indicamos, será:</p>

<ul>
<li>app/
<ul><li>lib/</li>
<li>Way/</li>
</ul></li>
</ul>

<p>Assim, ao invés de agrupar todos os repositórios em um único diretório <code>repositories</code>, uma abordagem mais elegante seria de categorizá-los em vários diretórios. Dessa forma:</p>

<ul><li>app/
<ul><li>lib/</li>
<li>Way/
<ul><li>Storage/</li>
<li>Post/
<ul><li>PostRepositoryInterface.php</li>
<li>EloquentPostRepository.php</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>É vital que adiramos a essa nomenclatura e convenção de diretórios, caso queiramos que a função de autocarregamento funcione como esperado. A única coisa faltando é atualizar o <em>namespace</em> de <code>PostRepositoryInterface</code> e <code>EloquentPostRepository</code>.</p>

<pre class="brush: php">
&lt;?php namespace Way\Storage\Post;

# app/lib/Way/Storage/Post/PostRepositoryInterface.php

interface PostRepositoryInterface {

  public function all();

  public function find($id);

  public function create($input);

}</pre>

<p>E para a implementação:</p>

<pre class="brush: php">
&lt;?php namespace Way\Storage\Post;

# app/lib/Way/Storage/Post/EloquentPostRepository.php

use Post;

class EloquentPostRepository implements PostRepositoryInterface {

  public function all()
  {
      return Post::all();
  }

  public function find($id)
  {
      return Post::find($id);
  }

  public function create($input)
  {
      return Post::create($input);
  }

}</pre>

<p>E é isso. Muito mais claro. MAs estão faltando as ligações, não? O arquivo de rotas pode até ser um lugar conveniente para experimentar as coisas, mas não faz sentido manter essas ligações permanentemente por lá. Ao invés disso, usaremos provedores de serviços.</p>

<blockquote>
<p>Provedores de serviço, nada mais são que classes de inicialização que podem ser usada para fazer qualquer coisa que quisermos: registrar uma ligação, riar um gancho para um evento, importar um arquivo de rotas, etc.</p>
</blockquote>

<p>O método <code>register()</code> de um provedor de serviço será chamado automaticamente pelo Laravel:</p>

<pre class="brush: php">
&lt;?php namespace Way\Storage;

# app/lib/Way/Storage/StorageServiceProvider.php

use Illuminate\Support\ServiceProvider;

class StorageServiceProvider extends ServiceProvider {

  // Chamado, automaticamente, pelo Laravel
  public function register()
  {
      $this-&gt;app-&gt;bind(
          'Way\Storage\Post\PostRepositoryInterface',
          'Way\Storage\Post\EloquentPostRepository'
      );
  }

}</pre>

<p>Para fazer com que o Laravel saiba desse arquivo, precisamos incluí-lo em outro arquivo, o <code>app/config/app.php</code>, na array <code>providers</code>.</p>

<pre class="brush: php">
# app/config/app.php

'providers' =&gt; array(
  'Illuminate\Foundation\Providers\ArtisanServiceProvider',
  'Illuminate\Auth\AuthServiceProvider',
  // ...
  'Way\Storage\StorageServiceProvider'
)</pre>

<p>Ótimo, agora temos um arquivo dedicado para registrarmos novas ligações.</p>

<h3>Atualizando os Testes</h3>

<p>Com a nossa estrutura, ao invés de simular o modelo Eloquent, poderemos simular a <code>PostRepositoryInterface</code>. Abaixo segue como ficará um teste com essa nova estrutura:</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $mock = Mockery::mock('Way\Storage\Post\PostRepositoryInterface');
  $mock-&gt;shouldReceive('all')-&gt;once();

  $this-&gt;app-&gt;instance('Way\Storage\Post\PostRepositoryInterface', $mock);

  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');
}</pre>

<p>Contudo, podemos aprimorar ainda mais. É um tanto claro que todo método de  <code>PostsControllerTest</code> precisará de uma versão simulada do repositório. Assim, é melhor extrairmos essa preparação para seu próprio método, dessa forma:</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function setUp()
{
  parent::setUp();

  $this-&gt;mock('Way\Storage\Post\PostRepositoryInterface');
}

public function mock($class)
{
  $mock = Mockery::mock($class);

  $this-&gt;app-&gt;instance($class, $mock);

  return $mock;
}

public function testIndex()
{
  $this-&gt;mock-&gt;shouldReceive('all')-&gt;once();

  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');
}</pre>

<p>Nada mal, hein?</p>

<p>Now, if you want to be super-fly, and are willing to add a touch of test logic to your production code, you could even perform your mocking within the Eloquent model! This would allow for:</p>

<pre class="brush: php">
Post::shouldReceive('all')-&gt;once();</pre>

<p>Behind the scenes, this would mock <code>PostRepositoryInterface</code>, and update the IoC binding. You can't get much more readable than that!</p>

<p>Allowing for this syntax only requires you to update the <code>Post</code> model, or, better, a <code>BaseModel</code> that all of the Eloquent models extend. Here's an example of the former:</p>

<pre class="brush: php">
&lt;?php

# app/models/Post.php

class Post extends Eloquent {

  public static function shouldReceive()
  {
      $class = get_called_class();
      $repo = "Way\\Storage\\{$class}\\{$class}RepositoryInterface";
      $mock = Mockery::mock($repo);

      App::instance($repo, $mock);

      return call_user_func_array([$mock, 'shouldReceive'], func_get_args());
  }

}</pre>

<p>If you can manage the inner "<em>Should I be embedding test logic into production code</em>" battle, you'll find that this allows for significantly more readable tests.</p>

<pre class="brush: php">
&lt;?php

# app/tests/controllers/PostsControllerTest.php

class PostsControllerTest extends TestCase {

  public function tearDown()
  {
      Mockery::close();
  }

  public function testIndex()
  {
      Post::shouldReceive('all')-&gt;once();

      $this-&gt;call('GET', 'posts');

      $this-&gt;assertViewHas('posts');
  }

  public function testStoreFails()
  {
      Input::replace($input = ['title' =&gt; '']);

      $this-&gt;call('POST', 'posts');

      $this-&gt;assertRedirectedToRoute('posts.create');
      $this-&gt;assertSessionHasErrors();
  }

  public function testStoreSuccess()
  {
      Input::replace($input = ['title' =&gt; 'Foo Title']);

      Post::shouldReceive('create')-&gt;once();

      $this-&gt;call('POST', 'posts');

      $this-&gt;assertRedirectedToRoute('posts.index', ['flash']);
  }

}</pre>

<p>It feels good, doesn't it? Hopefully, this article hasn't been too overwhelming. The key is to learn how to organize your repositories in such a way to make them as easy as possible to mock and inject into your controllers. As a result of that effort, your tests will be lightning fast!</p>

<blockquote>
<p>This article is an excerpt from book, <a href="https://leanpub.com/laravel-testing-decoded">Laravel Testing Decoded</a>.</p>
</blockquote>
