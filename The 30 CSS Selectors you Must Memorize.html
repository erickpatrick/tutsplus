<h1>Os 30 Seletores CSS Que Você Deve Memorizar</h1>

<p>Então, você aprender os seletores básicos: <code>identificador</code>, <code>classe</code>, e <code>descendente</code> - e achou que tinha aprendido tudo? Se acha que sim, então você está deixando de aproveitar uma gama de possibilidades. Enquanto a maioria dos seletores mencionados nesse artigo fazem parte da especificação do CSS3, e são, consequentemente, disponíveis apenas em navegadores modernos, você saber todos eles de cabeça.</p>

<h2><span> 1. </span>*</h2>

<pre class="brush: css">
* {
 margin: 0;
 padding: 0;
}</pre>

<p>Vamos falar primeiro dos mais óbvios, para os iniciantes, antes de começarmos a falar dos seletores mais avançados.</p>

<p>O asterísco (ou estrela) tem como alvo todos os elementos em uma página. Muitos desenvolvedores usam-no para zerar as as margens e o preenchimento (<code>margin</code>e <code>padding</code>, respectivamente). Embora isso funcione para testes rápidos, recomendo o não uso dessa técnica em produção. Ela deixa o navegador muito <em>pesado</em> (por ter de selecionar todo e cada elemento), além de ser desnecessário.</p>

<p>O <code>*</code> também pode ser usado como um seletor filho. </p>

<pre class="brush: css">
#container * {
 border: 1px solid black;
}</pre>

<p>Isso mirará todo elemento que for filho de uma <code>div</code> com id <code>#container</code>. Novamente, não use muito essa técnica em produção. De preferência, nunca.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/star.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/star.html">Visualizar Demonstração </a></h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 2. </span>#X</h2>

<pre class="brush: css">
#container {
 width: 960px;
 margin: auto;
}</pre>

<p>Prefixar um seletor com o "jogo da velha" (ou cerquilha, caso prefira), permite mirar algum elemento com algum <code>identificador</code>. Ele é um dos seletores mais usados, contudo, seja cuidadoso ao usar seletores com <code>identificador</code>.</p>

<blockquote>
<p>Faça-se a seguinte pergunta: Preciso, realmente, aplicar um <code>identificador</code> a esse elemento para poder selecioná-lo</p>
</blockquote>

<p>Seletores <code>identificador</code> são rígidos e não permitem reuso. Se possível, tente usar, primeiro, o nome da tag, um dos novos elementos do HTML5 ou uma pseudo-classe.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/id.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/id.html">Visualizar Demonstração </a> </h5>
<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 3. </span>.X</h2>

<pre class="brush: css">
.error {
color: red;
}</pre>

<p>Esse é um seletor de <code>classe</code>. A diferença entre um <code>identificador</code> e uma <code>classe</code> é que, com a classe, você pode selecionar vários elementos. Use uma <code>classe</code> quando você precisar estilizar um grupo de elementos. Alternativamente, use um <code>identificador</code> quando precisar achar "uma agulha num palheiro", para estilizar um único elemento.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/class.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/class.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 4. </span>X Y</h2>

<pre class="brush: css">
li a {
text-decoration: none;
}</pre>

<p>O próximo seletor mais comum é o seletor de <code>descendência</code>.Quando precisar ser mais específico em seus seletores, use esse. Por exemplo, se, ao invés de mirar todas as tags de âncora (<code>a</code>), talvez você só precise selecionar aquelas que estão dentro de uma lista não ordenada? Esse seletor, o seletor descendente, é especificamente para isso. </p>

<blockquote>
<p><strong>Dica</strong> - Se seu seletor parecer com isso <code>X Y Z A B.error</code>, tem algo errado. Pergunte-se se, realmente, é necessário todo esse peso, toda essa <em>especificidade</em>.</p>
</blockquote>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/descend.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/descend.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 5. </span>X</h2>

<pre class="brush: css">
a { color: red; }
ul { margin-left: 0; }</pre>

<p>E se você quiser selecionar todos os elementos da página, de acordo com o <code>tipo</code> deles, ao ivés do seu <code>identificador</code> ou <code>classe</code>? Faça o simples e use um seletor de tipo. Se você precisar selecionar todas as listas não ordenadas, use <code>ul {}</code>.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/tagName.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/tagName.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 6. </span>X:visited e X:link</h2>

<pre class="brush: css">
a:link { color: red; }
a:visted { color: purple; }</pre>

<p>We use the <code>:link</code> pseudo-class to target all anchors tags which have yet to be clicked on.</p>

<p>Alternatively, we also have the <code>:visited</code> pseudo class, which, as you'd expected, allows us to apply specific styling to only the anchor tags on the page which <em>have</em> been clicked on, or <em>visited</em>.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/links.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/links.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span>7.</span> X + Y</h2>

<pre class="brush: css">
ul + p {
 color: red;
}</pre>

<p>Isso é referenciado como seletor adjacente. Ele selecionará <em>somente</em> o elemento imediatamente após o primeiro elemento. No exemplo acima, selecionará só o primeiro parágrado após cada <code>ul</code> na página, e fará que ele tenha a cor vermelha.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/adjacent.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/adjacent.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span>8.</span> X &gt; Y</h2>

<pre class="brush: css">
div#container &gt; ul {
border: 1px solid black;
}</pre>

<p>A diferença entre o seletor descendente <code>X Y</code> padrão e o seletor <code>X &gt; Y</code> é que o último somente seleciona filhos diretos. Por exemplo, considere o código HTML abaixo.</p>

<pre class="brush: html">
 &lt;div id="container"&gt;
    &lt;ul&gt;
       &lt;li&gt; Item da lista
         &lt;ul&gt;
            &lt;li&gt; Filho &lt;/li&gt;
         &lt;/ul&gt;
       &lt;/li&gt;
       &lt;li&gt; Item da lista &lt;/li&gt;
       &lt;li&gt; Item da lista &lt;/li&gt;
       &lt;li&gt; Item da lista &lt;/li&gt;
    &lt;/ul&gt;
 &lt;/div&gt;</pre>

<p>Um seletor <code>#container &gt; ul</code> somente selecionará aquelas <code>ul</code>s que são filhas diretas de uma <code>div</code> com <code>identificador</code> nomeado como <code>container</code>. Ele não selecionará, por exemplo, a <code>ul</code> que é filha do primeiro <code>li</code>. </p>

<p>Por esse motivo, há benefícios relacionados a performances ao usar o combinador de filhos. Na verdade, é recomendável utilizá-lo quando estiver trabalhando com motores de seleção de CSS criados em JavaScript.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/childcombinator.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/childcombinator.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 9.</span> X ~ Y</h2>

<pre class="brush: css">
ul ~ p {
 color: red;
}</pre>

<p>O seletor de irmão é parecido com o seletor <code>X + Y</code>, contudo, é menos restritivo. Enquanto o seletor adjacente (<code>ul + p</code>) só selecionará o primeiro elemento, imediatamente, após o elemento inicial, esse é mais generalista. Ele selecionará, usando o nosso exemplo acima, qualquer elemento <code>p</code>, desde que ele venha depois de um elemento <code>ul</code>. </p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/generalcombinator.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/generalcombinator.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 10.</span> X[title]</h2>

<pre class="brush: css">
a[title] {
 color: green;
}</pre>

<p>Chamado de <em>seletor de atributos</em>, no nosso exemplo acima, ele só selecionará aquelas âncoras com um atributo <code>title</code> attribute. As âncoras que não tiverem esse atributo, não receberão esse estilo em particular. Mas, e se precisarmos ser mais específicos? Bem...</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 11.</span> X[href="foo"]</h2>

<pre class="brush: css">
a[href="http://net.tutsplus.com"] {
color: #1f6053; /* nettuts green */
}</pre>

<p>O trecho acima estilizará todas as âncoras que apontem para o endereço <em>http://net.tutsplus.com</em>; eles serão estilizados com o nosso verde. Todas as outras âncoras não serão afetadas.</p>
<blockquote>

<p>Atente que estamos envolvendo o valor entre aspas. Lembre-se de fazer isso quando estiver trabalhando com motores de seleção CSS criados em JavaScript. Quando possível, sempre use os seletores CSS3 ao invés dos métodos não oficiais.</p>
</blockquote>

<p>Ele funciona muito bem, embora seja um tanto rígido. E se o link, realmente, direcionar para o Nettuts+, mas, o endereço usado seja o <em>nettuts.com</em> ao invés da URL completa? Para esses casos, podemos usar a sintaxe de expressões regulares.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes2.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes2.html">Visualizar Demonstração</a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 12.</span> X[href*="nettuts"]</h2>

<pre class="brush: css">
a[href*="tuts"] {
color: #1f6053; /* nettuts green */
}</pre>

<p>Aqui está; é isso o que precisamos. O asterísco designa que o valor utilizado no seletor deve aparecer em <em>algum lugar</em> do valor do atributo do elemento. Assim, esse novo seletor cobre <em>nettuts.com</em>, <em>net.tutsplus.com,</em> e até o <em>tutsplus.com</em>. </p>

<p>Tenha em mente que ele é bem abrangente. E se a âncora apontar para alguma site que não seja da Envato, mas que tenha em sua URL a cadeia de caracteres <em>tuts</em>? Quando precisar ser mais específico, use <code>^</code> e <code>&amp;</code>, para referenciar o começo e o fim de uma cadeia de caracteres, respectivamente.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes3.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes3.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 13. </span> X[href^="http"]</h2>

<pre class="brush: css">
a[href^="http"] {
 background: url(path/to/external/icon.png) no-repeat;
 padding-left: 10px;
}</pre>

<p>Você, alguma vez, já parou para pensar como alguns sites fazem para mostrar um pequeno ícone ao lado de alguns links que levam para outros sites? Tenho certeza que você já viu algo parecido antes; Eles são ótimos lembretes que o link em questão levará você para um site completamente diferente.</p>

<p>Isso é bem fácil de fazer, usando o ácento circunflexo. Ele é, comumente, usado em expressões regulares para designar o começo de uma cadeia de caracteres. Se quisermos selecionar todas as âncoras que tem um atributo <code>href</code> que começam com <code>http</code>, nós poderíamos usar um trecho de código parecido com o que temos acima.</p>

<blockquote>
<p>Atente que não estamos procurando por <code>http://</code>; isso é desnecessário e não leva em consideração as URLs que começam com <code>https://</code>. </p>
</blockquote>

<p>Agora, e se quiséssemos estilizar todos os links que apontam, digamos, para uma foto? Nesses casos, temos de pesquisar pelo <em>final</em> da cadeia de caracteres.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes4.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes4.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 14. </span>X[href$=".jpg"]</h2>

<pre class="brush: css">
a[href$=".jpg"] {
 color: red;
}</pre>

<p>Again, we use a regular expressions symbol, <code>$</code>, to refer to the end of a string. In this case, we're searching for all anchors which link to an image -- or at least a url that ends with <code>.jpg</code>. Keep in mind that this certainly won't work for <code>gifs</code> and <code>pngs</code>.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes5.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes5.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 15.</span> X[data-*="foo"]</h2>

<pre class="brush: css">
a[data-filetype="image"] {
 color: red;
}</pre>

<p>Lembre-se do exemplo oito; como fazer para referenciar todos os tipos de imagens: <code>png</code>, <code>jpeg,</code><code>jpg</code> e <code>gif</code>? Bem, poderíamos criar múltiplos seletores, dessa forma:</p>

<pre class="brush: css">
a[href$=".jpg"],
a[href$=".jpeg"],
a[href$=".png"],
a[href$=".gif"] {
 color: red;
}</pre>

<p>Mas, isso é muito chato e ineficiente. Outra possível solução é usar atributos customizados. E se adicionarmos um atributo <code>data-filetype</code> a cada uma das âncoras que apontem para uma imagem?</p>

<pre class="brush: html">
&lt;a href="path/to/image.jpg" data-filetype="image"&gt; Link para Imagem&lt;/a&gt;</pre>

<p>Então, com esse <em>gancho</em>, podemos usar os seletores de atributo padrão para selecionar somente essas âncoras. </p>

<pre class="brush: css">
a[data-filetype="image"] {
 color: red;
}</pre>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes6.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes6.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 16. </span>X[foo~="bar"]</h2>

<pre class="brush: css">
 a[data-info~="external"] {
 color: red;
}

a[data-info~="image"] {
 border: 1px solid black;
}</pre>

<p>Eis um seletor especial que impressionará seus amigos. Nem todo mundo sabe desse truque. O til (<code>~</code>) permite-nos selecionar um atributo que tem, em seus valores, uma lista separada por espaços. </p>

<p>Seguindo com o nosso atributo customizado do seletor quinze, poderíamos criar um atributo <code>data-info</code>, que pode receber uma lista de itens, separados por espaço, para podermos anotar o que quisermos. Nesse caso, nós tomaremos nota dos links externos e dos links para iamgens &ndash; só para exemplificar.</p>

<pre class="brush: html">
"&lt;a href="path/to/image.jpg" data-info="external image"&gt; Clique em mim &lt;/a&gt;</pre>

<p>Com esse código, agora podemos selecionar qualquer tag que tenha qualquer um desses valores, usando o truque do seletor de atributos com o ~.</p>

<pre class="brush: css">
/* Selecionar o atributo data-info que contem o valor "external" */
a[data-info~="external"] {
 color: red;
}

/* E aquele que contem o valor "image" */
a[data-info~="image"] {
border: 1px solid black;
}</pre>

<p>Pretty nifty, ay?</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes7.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes7.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 17.</span> X:checked</h2>

<pre class="brush: css">
input[type=radio]:checked {
 border: 1px solid black;
}</pre>

<p>Essa pseudo-classe somente selecionará o elemento da interface que foi marcado como selecionado &ndash; como um botão <code>radio</code> ou <code>checkbox</code>. Simples assim.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/checked.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/checked.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 18. </span>X:after</h2>

<p>As pseudo-classes <code>before</code> e <code>after</code> são muito boas. Parece que, todos os dias, o pessoal encontra maneiras criativas e efetivas de usá-las. Elas, simplesmente, geram conteúdo ao redor do elemento selecionado.</p>

<p>Vários aprenderam sobre eles quando foram encontrar o <em>hack</em> do ajuste dos <em>floats</em> (alguns conhecem como <em>clear-fix hack</em>).</p>

<pre class="brush: css">
.clearfix:after {
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
  font-size: 0;
  height: 0;
  }

.clearfix { 
 *display: inline-block; 
 _height: 1%;
}</pre>

<p>Esse <em>hack</em> usa a pseudo-classe <code>:after</code> para adicionar um espaço após o elemento e, então, limpa-lo. É um ótimo truque para se ter em seu cinto de utilidades, principalmente quando a técnica do <code>overflow: hidden;</code> não é possível ser utilizada.</p>

<p>Para outros usos criativos dessa técnica, <a href="http://net.tutsplus.com/tutorials/html-css-techniques/quick-tip-getting-clever-with-css3-shadows/">veja meu guia rápido sobre como criar sombras</a>. </p>

<blockquote>
<p>De acordo com a especificação dos Seletores CSS3, você deveria, tecnicamente, usar a sintaxe dos pseudo-elementos de dois "dois pontos", <code>::</code>. Entretanto, para manter-se compatível, o navegador aceitar o uso com um único "dois pontos". Na verdade, é melhor você usar a versão com um único "dois pontos" em seus projetos.</p>
</blockquote>

<h3> Compatibilidade </h3>
<ul><li>IE8+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 19. </span>X:hover</h2>

<pre class="brush: css">
div:hover {
background: #e3e3e3;
}</pre>

<p>Oh come on. You know this one. The official term for this is <code>user action pseudo class</code>. It sounds confusing, but it really isn't. Want to apply specific styling when a user hovers over an element? This will get the job done!</p>

<blockquote>
<p>Keep in mind that older version of Internet Explorer don't respond when the <code>:hover</code> pseudo class is applied to anything other than an anchor tag. </p>
</blockquote>

<p>You'll most often use this selector when applying, for example, a <code>border-bottom</code> to anchor tags, when hovered over.</p>

<pre class="brush: css">
a:hover {
 border-bottom: 1px solid black;
}</pre>

<blockquote>
<p><strong>Pro-tip</strong> - <code>border-bottom: 1px solid black;</code> looks better than <code>text-decoration: underline;</code>. </p>
</blockquote>

<h3> Compatibilidade </h3>
<ul><li>IE6+ (In IE6, :hover must be applied to an anchor element) </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 20. </span> X:not(selector)</h2>

<pre class="brush: css">
div:not(#container) {
 color: blue;
}</pre>

<p>The <code>negation</code> pseudo class is particularly helpful. Let's say I want to select all divs, except for the one which has an <code>identificador</code> of <code>container</code>. The snippet above will handle that task perfectly.</p>

<p>Or, if I wanted to select every single element (not advised) except for paragraph tags, we could do:</p>

<pre class="brush: css">
*:not(p) {
color: green;
}</pre>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/not.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/not.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 21. </span> X::pseudoElement</h2>

<pre class="brush: css">
p::first-line {
 font-weight: bold;
 font-size: 1.2em;
}</pre>

<p>We can use pseudo elements (designated by <code>::</code>) to style fragments of an element, such as the first line, or the first letter. Keep in mind that these must be applied to block level elements in order to take effect.</p>

<blockquote>
<p>A pseudo-element is composed of two colons: <code>::</code></p>
</blockquote>

<h4>Target the First Letter of a Paragraph</h4>

<pre class="brush: css">
p::first-letter {
 float: left;
 font-size: 2em;
 font-weight: bold;
 font-family: cursive;
 padding-right: 2px;
}</pre>

<p>This snippet is an abstraction that will find all paragraphs on the page, and then sub-target only the first letter of that element. </p>

<p>This is most often used to create newspaper-like styling for the first-letter of an article.</p>

<h4>Target the First Line of a Paragraph</h4>

<pre class="brush: css">
p::first-line {
 font-weight: bold;
 font-size: 1.2em;
}</pre>

<p>Similarly, the <code>::first-line</code> pseudo element will, as expected, style the first line of the element only. </p>

<blockquote>
<p>"For Compatibilidade with existing style sheets, user agents must also accept the previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2 (namely, :first-line, :first-letter, :before and :after). This Compatibilidade is not allowed for the new pseudo-elements introduced in this specification." - <a href="http://www.w3.org/TR/css3-selectors/">Source</a></p>
</blockquote>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/pseudoElements.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/pseudoElements.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 22. </span>X:nth-child(n)</h2>

<pre class="brush: css">
li:nth-child(3) {
 color: red;
}</pre>

<p>Remember the days when we had no way to target specific elements in a stack? The <code>nth-child</code> pseudo class solves that!</p>

<p>Please note that <code>nth-child</code> accepts an integer as a parameter, however, this is not zero-based. If you wish to target the second list item, use <code>li:nth-child(2)</code>. </p>

<p>We can even use this to select a variable set of children. For example, we could do <code>li:nth-child(4n)</code> to select every fourth list item. </p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nth.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/nth.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
</ul>

<h2><span> 23. </span>X:nth-last-child(n)</h2>

<pre class="brush: css">
li:nth-last-child(2) {
 color: red;
}</pre>

<p>What if you had a huge list of items in a <code>ul</code>, and only needed to access, say, the third to the last item? Rather than doing <code>li:nth-child(397)</code>, you could instead use the <code>nth-last-child</code> pseudo class.</p>

<p>This technique works almost identically from number sixteen above, however, the difference is that it begins at the end of the collection, and works its way back.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthLast.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/nthLast.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 24. </span>X:nth-of-type(n)</h2>

<pre class="brush: css">
ul:nth-of-type(3) {
 border: 1px solid black;
}</pre>

<p>There will be times when, rather than selecting a <code>child</code>, you instead need to select according to the <code>type</code> of element. </p>

<p>Imagine mark-up that contains five unordered lists. If you wanted to style only the third <code>ul</code>, and didn't have a unique <code>identificador</code> to hook into, you could use the <code>nth-of-type(n)</code> pseudo class. In the snippet above, only the third <code>ul</code> will have a border around it.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthOfType.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/nthOfType.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
</ul>

<h2><span> 25. </span>X:nth-last-of-type(n)</h2>

<pre class="brush: css">
ul:nth-last-of-type(3) {
 border: 1px solid black;
}</pre>

<p>And yes, to remain consistent, we can also use <code>nth-last-of-type</code> to begin at the end of the selectors list, and work our way back to target the desired element.</p>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 26. </span>X:first-child</h2>

<pre class="brush: css">
ul li:first-child {
 border-top: none;
}</pre>

<p>This structural pseudo class allows us to target only the first child of the element's parent. You'll often use this to remove borders from the first and last list items. </p>

<p>For example, let's say you have a list of rows, and each one has a <code>border-top</code> and a <code>border-bottom</code>. Well, with that arrangement, the first and last item in that set will look a bit odd. </p>

<p>Many designers apply classes of <code>first</code> and <code>last</code> to compensate for this. Instead, you can use these pseudo classes.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html" data-original-url="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+  </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 27. </span>X:last-child</h2>

<pre class="brush: css">
ul &gt; li:last-child {
 color: green;
}</pre>

<p>The opposite of <code>first-child</code>, <code>last-child</code> will target the last item of the element's parent.</p>

<h3>Example</h3>
<p>Let's build a simple example to demonstrate one possible use of these classes. We'll create a styled list item. </p>

<h4>Markup</h4>
<pre class="brush: html">
&lt;ul&gt;
   &lt;li&gt; List Item &lt;/li&gt;
   &lt;li&gt; List Item &lt;/li&gt;
   &lt;li&gt; List Item &lt;/li&gt;
&lt;/ul&gt;</pre>

<p>Nothing special here; just a simple list.</p>

<h4>CSS</h4>
<pre class="brush: css">
ul {
 width: 200px;
 background: #292929;
 color: white;
 list-style: none;
 padding-left: 0;
}

li {
 padding: 10px;
 border-bottom: 1px solid black;
 border-top: 1px solid #3c3c3c;
}</pre>

<p>This styling will set a background, remove the browser-default padding on the <code>ul</code>, and apply borders to each <code>li</code> to provide a bit of depth.</p>

<figure>
<img src="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/extraBorders.png" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/extraBorders.png" alt="Styled List" /></figure>

<blockquote>
<p>To add depth to your lists, apply a <code>border-bottom</code> to each <code>li</code> that is a shade or two darker than the <code>li</code>'s background color. Next, apply a <code>border-top</code> which is a couple shades <em>lighter</em>. </p>
</blockquote>

<p>The only problem, as shown in the image above, is that a border will be applied to the very top and bottom of the unordered list - which looks odd. Let's use the <code>:first-child</code> and <code>:last-child</code> pseudo classes to fix this.</p>

<pre class="brush: css">
li:first-child {
  border-top: none;
}

li:last-child {
 border-bottom: none;
}</pre>

<figure>
<img src="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/fixed.png" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/fixed.png" alt="Fixed" /></figure>
<p>There we go; that fixes it!</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html" data-original-url="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<p><em>Yep - IE8 supported <code>:first-child</code>, but not <code>:last-child</code>. Go figure. </em> </p>

<h2><span> 28. </span>X:only-child</h2>

<pre class="brush: css">
div p:only-child {
 color: red;
}</pre>

<p>Truthfully, you probably won't find yourself using the <code>only-child</code> pseudo class too often. Nonetheless, it's available, should you need it.</p>

<p>It allows you to target elements which are the <em>only</em> child of its parent. For example, referencing the snippet above, only the paragraph that is the only child of the <code>div</code> will be colored, red.</p>

<p>Let's assume the following markup.</p>

<pre class="brush: html">
&lt;div&gt;&lt;p&gt; My paragraph here. &lt;/p&gt;&lt;/div&gt;

&lt;div&gt;
 &lt;p&gt; Two paragraphs total. &lt;/p&gt;
 &lt;p&gt; Two paragraphs total. &lt;/p&gt;
&lt;/div&gt;</pre>

<p>In this case, the second <code>div</code>'s paragraphs will not be targeted; only the first <code>div</code>. As soon as you apply more than one child to an element, the <code>only-child</code> pseudo class ceases to take effect.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyChild.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/onlyChild.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 29. </span>X:only-of-type</h2>

<pre class="brush: css">
li:only-of-type {
 font-weight: bold;
}</pre>

<p>This structural pseudo class can be used in some clever ways. It will target elements that do not have any siblings within its parent container. As an example, let's target all <code>ul</code>s, which have only a single list item. </p>

<p>First, ask yourself how you would accomplish this task? You could do <code>ul li</code>, but, this would target <em>all</em> list items. The only solution is to use <code>only-of-type</code>.</p>

<pre class="brush: css">
ul &gt; li:only-of-type {
 font-weight: bold;
}</pre>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyOfType.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/onlyOfType.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 30. </span>X:first-of-type</h2>

<p>The <code>first-of-type</code> pseudo class allows you to select the first siblings of its type. </p>

<h4>A Test</h4>
<p>To better understand this, let's have a test. Copy the following mark-up into your code editor:</p>

<pre class="brush: html">
&lt;div&gt;
 &lt;p&gt; My paragraph here. &lt;/p&gt;
 &lt;ul&gt;
    &lt;li&gt; List Item 1 &lt;/li&gt;
    &lt;li&gt; List Item 2 &lt;/li&gt;
 &lt;/ul&gt;

 &lt;ul&gt;
    &lt;li&gt; List Item 3 &lt;/li&gt;
    &lt;li&gt; List Item 4 &lt;/li&gt;
 &lt;/ul&gt;   
&lt;/div&gt;</pre>

<p>Now, without reading further, try to figure out how to target only <em>"List Item 2"</em>. When you've figured it out (or given up), read on.</p>

<h4>Solution 1</h4>
<p>There are a variety of ways to solve this test. We'll review a handful of them. Let's begin by using <code>first-of-type</code>. </p>

<pre class="brush: css">
ul:first-of-type &gt; li:nth-child(2) {
 font-weight: bold;
}</pre>

<p>This snippet essentially says, "find the first unordered list on the page, then find only the immediate children, which are list items. Next, filter that down to only the second list item in that set.</p>

<h4>Solution 2</h4>
<p>Another option is to use the adjacent selector.</p>

<pre class="brush: css">
p + ul li:last-child {
 font-weight: bold;
}</pre>

<p>In this scenario, we find the <code>ul</code> that immediately proceeds the <code>p</code> tag, and then find the very last child of the element.</p>

<h4>Solution 3</h4>
<p>We can be as obnoxious or as playful as we want with these selectors. </p>

<pre class="brush: css">
ul:first-of-type li:nth-last-child(1) {
 font-weight: bold;   
}</pre>

<p>This time, we grab the first <code>ul</code> on the page, and then find the very first list item, but starting from the bottom! :)</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstOfType.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/firstOfType.html">Visualizar Demonstração </a> </h5>
<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox 3.5+</li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2>Conclusion </h2>

<p>If you're compensating for older browsers, like Internet Explorer 6, you still need to be careful when using these newer selectors. But, please don't let that deter you from learning these. You'd be doing a huge disservice to yourself. Be sure to <a href="http://www.quirksmode.org/css/contents.html">refer here for a browser-Compatibilidade list.</a> Alternatively, you can use <a href="http://code.google.com/p/ie7-js/">Dean Edward's excellent IE9.js script</a> to bring support for these selectors to older browsers.  </p>

<p>Secondly, when working with JavaScript libraries, like the popular jQuery, always try to use these native CSS3 selectors over the library's custom methods/selectors, when possible. I<a href="http://jsperf.com/jquery-css3-not-vs-not">t'll make your code faster</a>, as the selector engine can use the browser's native parsing, rather than its own. </p>

<p>Thanks for reading, and I hope you picked up a trick or two!</p>
