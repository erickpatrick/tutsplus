<h1>Princípios SOLID Parte 1 - O Princípio da Responsabilidade Única</h1>

<p>Responsabilidade Única (SRP - Single Responsability), Aberto/Fechado (Open/Close), Substituição de Liskov (Liskov's Substitution), Segredação de Interface (Interface Segregation), e Inversão de Dependência (Dependency Inversion). Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<h2>A Definição</h2>

<blockquote>
<p>Uma classe só deveria ter um único motivo para mudar.</p>
</blockquote>

<p>Definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e, depois, republicado na versão com C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, é um dos princípios ágeis de programação, conhecidos como princípios SOLID. O que ele afirma é bem simples, porém, alcançar essa simplicidade pode ser bem problemático. Uma classe só deveria ter um único motivo para mudar.</p>

<p>Mas, por que? Por que é tão importante ter apenas um único motivo para mudar?</p>

<p>Em linguagens compiladas e fortemente tipadas, há muitos motivos que podem levar a muitas reimplantações indesejadas. Se há dois motivos diferentes para uma mudança, é aceitável que duas equipes diferentes possam trabalhar no mesmo código por motivos diferentes. Cada uma terá de implantar sua solução, o que, no caso de linguagens compiladas (como C++, C# ou Java), pode causar imcompatibilidade de módulos com módulos criados por outras equipes ou de outras partes da aplicação.</p>

<p>Mesmo que você não use uma linguagem compilada, talvez tenha de retestar uma mesma classe ou módulo por diferentes motivos. Isso implica em mais tempo, esforço, recursos e trabalho.</p>


<h2>A Audiêcia</h2>

<p>Determinar a única responsabilidade de uma classe ou módulo, é muito mais complexo que, simplesmente, verificar uma lista pré-determianda. Por exemplo, uma dica para encontrarmos as razões para mudanças é verificar o audiência da nossa classe. Os usuários da aplicação ou sistema que desenvolvemos é que requisitarão mudanças para ela. Aqueles que usam que pedirão mudanças. Eis alguns módulos e suas possíveis audiências.</p>

<ul>
<li><strong>Módulo de Persistência</strong> - Pode incluir os DBAs e arquitetos de software;</li>
<li><strong>Módulo de Relatório</strong> - Pode incluir os contadores, secretários e operadores;</li>
<li><strong>Módulo de Computação de Pagamento para um Sistema de Pagamento</strong> - pode incluir os advogados, administradores e contadores;</li>
<li><strong>Módulo de Busca de Livros para um Sistema de Administração de Biblioteca</strong> - Pode incluir os bibliotecários e/ou os próprios clientes.</li>
</ul>

<h2>Atores e Papéis</h2>

<p>Associar pessoas reais a todas os papéis pode ser difícil. Em uma pequena empresa, uma única pessoa pode ter de satisfazer vários papéis, enquanto em uma empresa maior, pode ter várias pessoas alocadas para um mesmo papel. Assim, faz bastante sentido pensar sobre esses papéis. Mas os papéis em si são um pouco difíceis de definir. O que é um papel? Como o encontramos? É muito mais fácil pensar em pessoas realizando determinados papéis e associa-los à nossa audiência.</p>

<p>Assim, se nossa audiência define os motivos para as mudanças, os atores definem a audiência. Isso nos ajuda a reduzir os conceitos de pessoas como "John o arquiteto" em Arquitetura, ou "Maria a Diretora" em Gerência.</p>

<blockquote>
<p>Então, uma responsabilidade é um conjunto de funções que serve um ator em particular. (Robert C. Martin)</p>
</blockquote>

<h2>Fonte da Mudança</h2>

<p>Seguindo esse raciocínio, os atores tornam-se a fonte da mudança para a família de funções que os servem. De acordo que suas necessidades mudam, aquela família de funções também deve mudar para adaptar-se às suas necessidades.</p>

<blockquote>
<p>O ator de uma responsabilidade é a única fonte de mudança para aquela responsabilidade. (Robert C. Martin)</p>
</blockquote>

<h2>Classic Examples</h2>

<h3>Objects That Can "Print" Themselves</h3>

<p>Let's say we have a <code>Book</code> class encapsulating the concept of a book and its functionalities.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "A Great Book";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// pointer to next page
	}

	function printCurrentPage() {
		echo "current page content";
	}
}</pre>

<p>This may look like a reasonable class. We have book, it can provide its title, author and it can turn the page. Finally, it is also able to print the current page on the screen. But there is a little problem. If we think about the actors involved in operating the <code>Book</code> object, who might they be? We can easily think of two different actors here: Book Management (like the librarian) and Data Presentation Mechanism (like the way we want to deliver the content to the user - on-screen, graphical UI, text-only UI, maybe printing). These are two very different actors.</p>

<p>Mixing business logic with presentation is bad because it is against the Single Responsibility Principle (SRP). Take a look at the following code:</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "A Great Book";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// pointer to next page
	}

	function getCurrentPage() {
		return "current page content";
	}

}

interface Printer {

	function printPage($page);
}

class PlainTextPrinter implements Printer {

	function printPage($page) {
		echo $page;
	}

}

class HtmlPrinter implements Printer {

	function printPage($page) {
		echo '&lt;div style="single-page"&gt;' . $page . '&lt;/div&gt;';
	}

}</pre>

<p>Even this very basic example shows how separating presentation from business logic, and respecting SRP, gives great advantages in our design's flexibility.</p>

<h3>Objects That Can "Save" Themselves</h3>

<p>A similar example to the one above is when an object can save and retrieve itself from presentation.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "A Great Book";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// pointer to next page
	}

	function getCurrentPage() {
		return "current page content";
	}

	function save() {
		$filename = '/documents/'. $this-&gt;getTitle(). ' - ' . $this-&gt;getAuthor();
		file_put_contents($filename, serialize($this));
	}

}</pre>

<p>We can, again identify several actors like Book Management System and Persistence. Whenever we want to change persistence, we need to change this class. Whenever we want to change how we get from one page to the next, we have to modify this class. There are several axis of change here.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "A Great Book";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// pointer to next page
	}

	function getCurrentPage() {
		return "current page content";
	}

}

class SimpleFilePersistence {

	function save(Book $book) {
		$filename = '/documents/' . $book-&gt;getTitle() . ' - ' . $book-&gt;getAuthor();
		file_put_contents($filename, serialize($book));
	}

}</pre>

<p>Moving the persistence operation to another class will clearly separate the responsibilities and we will be free to exchange persistence methods without affecting our <code>Book</code> class. For example implementing a <code>DatabasePersistence</code> class would be trivial and our business logic built around operations with books will not change.</p>

<h2>A Higher Level View</h2>

<p>In my previous articles I frequently mentioned and presented the high level architectural schema that can be seen below.</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2013/12/HighLevelDesign.png" height="388"><br>
</figure>

<p>If we analyze this schema, you can see how the Single Responsibility Principle is respected. Object creation is separated on the right in Factories and the main entry point of our application, one actor one responsibility. Persistence is also taken care of at the bottom. A separate module for the separate responsibility. Finally, on the left, we have presentation or the delivery mechanism if you wish, in the form of an MVC or any other type of UI. SRP respected again. All that remains is to figure out what to do inside of our business logic.</p>

<h2>Software Design Considerations</h2>

<p>When we think about the software that we need to write, we can analyze many different aspects. For example, several requirements affecting the same class may represent an axis of change. This axes of change may be a clue for a single responsibility. There is a high probability that groups of requirements that are affecting the same group of functions will have reasons to change or be specified in the first place.</p>

<p>The primary value of software is ease of change. The secondary is functionality, in the sense of satisfying as much requirements as possible, meeting the user's needs. However, in order to achieve a high secondary value, a primary value is mandatory. To keep our primary value high, we must have a design that is easy to change, to extend, to accommodate new functionalities and to ensure that SRP is respected.</p>

<p>We can reason in a step by step manner:</p>

<ol>
<li>High primary value leads in time to high secondary value.</li>
<li>Secondary value means needs of the users.</li>
<li>Needs of the users means needs of the actors.</li>
<li>Needs of the actors determines the needs of changes of these actors.</li>
<li>Needs of change of actors defines our responsibilities.</li>
</ol>

<p>So when we design our software we should:</p>

<ol>
<li>Find and define the actors.</li>
<li>Identify the responsibilities that serve those actors.</li>
<li>Group our functions and classes so that each has only one allocated responsibility.</li>
</ol>

<h2>A Less Obvious Example</h2>

<pre class="brush: php">class Book {

	function getTitle() {
		return "A Great Book";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// pointer to next page
	}

	function getCurrentPage() {
		return "current page content";
	}

	function getLocation() {
		// returns the position in the library
		// ie. shelf number &amp; room number
	}

}</pre>

<p>Now this may appear perfectly reasonable. We have no method dealing with persistence, or presentation. We have our <code>turnPage()</code> functionality and a few methods to provide different information about the book. However, we may have a problem. To find out, we might want to analyze our application. The function <code>getLocation()</code> may be the problem.</p>

<p>All of the methods of the <code>Book</code> class are about business logic. So our perspective must be from the business's point of view. If our application is written to be used by real librarians who are searching for books and giving us a physical book, then SRP might be violated.</p>

<p>We can reason that the actor operations are the ones interested in the methods <code>getTitle()</code>, <code>getAuthor()</code> and <code>getLocation()</code>. The clients may also have access to the application to select a book and read the first few pages to get an idea about the book and decide if they want it or not. So the actor readers may be interested in all the methods except <code>getLocations()</code>. An ordinary client doesn't care where the book is kept in the library. The book will be handed over to the client by the librarian. So, we do indeed have a violation of SRP.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "A Great Book";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// pointer to next page
	}

	function getCurrentPage() {
		return "current page content";
	}

}

class BookLocator {

	function locate(Book $book) {
		// returns the position in the library
		// ie. shelf number &amp; room number
		$libraryMap-&gt;findBookBy($book-&gt;getTitle(), $book-&gt;getAuthor());
	}

}</pre>

<p>Introducing the <code>BookLocator</code>, the librarian will be interested in the <code>BookLocator</code>. The client will be interested in the <code>Book</code> only. Of course, there are several ways to implement a <code>BookLocator</code>. It can use the author and title or a book object and get the required information from the <code>Book</code>. It always depends on our business. What is important is that if the library is changed, and the librarian will have to find books in a differently organized library, the <code>Book</code> object will not be affected. In the same way, if we decide to provide a pre-compiled summary to the readers instead of letting them browse the pages, that will not affect the librarian nor the process of finding the shelf the books sits on.</p>

<p>However, if our business is to eliminate the librarian and create a self-service mechanism in our library, then we may consider that SRP is respected in our first example. The readers are our librarians also, they need to go and find the book themselves and then check it out at the automated system. This is also a possibility. What is important to remember here is that you must always consider your business carefully.</p>

<h2>Final Thoughts</h2>

<p>The Single Responsibility Principle should always be considered when we write code. Class and module design is highly affected by it and it leads to a low coupled design with less and lighter dependencies. But as any coin, it has two faces. It is tempting to design from the beginning of our application with SRP in mind. It is also tempting to identify as many actors as we want or need. But this is actually dangerous - from a design point of view - to try and think of all the parties from the very beginning. Excessive SRP consideration can easily lead to premature optimization and instead of a better design, it may lead to a scattered one where the clear responsibilities of classes or modules may be hard to understand. </p>

<p>So, whenever you observe that a class or module starts to change for different reasons, don't hesitate, take the necessary steps to respect SRP, however don't overdue it because premature optimization can easily trick you.</p>
