<h1>SOLID: Part 2 - The Open/Closed Principle</h1>

<p><a href="http://code.tutsplus.com/pt/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Responsabilidade Única (SRP - Single Responsability)</a>, Aberto para Expansão, Fechado para Modificações (Open/Close); Substituição de Liskov (Liskov's Substitution); Segregação de Interface (Interface Segregation); e Inversão de Dependência (Dependency Inversion). Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<h2>Definição</h2>

<blockquote>
	<p>Entidades de software (classes, módulos, funções, etc) devem ser abertas para expansão, porém, fechadas para modificações.</p>
</blockquote>

<p>O princípior do Aberto para Expansão, fechado para Modificação (The Open/Closed Principle - OCP), é creditado a <a href="http://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Mayer</a>, programador francês, publicando, primeiramente, em seu livro <a href="http://www.amazon.com/Object-Oriented-Software-Construction-CD-ROM-Edition/dp/0136291554">Object-Oriented Software Construction</a>, de 1988.</p>

<p>Esse princípio cresceu em popularidade no começo dos anos 2000 quando ele passou a integrar os princípios SOLID, definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e, mais tarde, republicado na versão em C# do mesmo livro <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>.</p>

<p>Basicamente, o que estamos falando aqui é sobre projetar nossos módulos, classes e funções, de forma que, quando uma nova funcionalidade for necessária, nós não deveríamos modificar o código existente, mas criar novo código que será usado pelo código atual. Isso parece um pouco estranho, especialmente se você vem de linguagens como o Java, C, C++ ou C# onde isso se aplica, não só ao código fonte em si, mas, também, ao código compilado. Nós queremos criar novas funcionalidades de forma que não seja necessário reimplantar nossos binários, executáveis ou DLLs existentes.</p>

<h2>OCP no contexto dos Princípios SOLID</h2>

<p>De acordo com que avançamos com esses tutoriais, podemos trabalhar os novos princípios nos contextos daqueles já discutidos. Nós já discutimos sobre o <a href="http://code.tutsplus.com/pt/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Princípio da Responsabilidade Única (SRP)</a>, que afirmou que um módulo deve ter, apenas, um único motivo para mudar. Se pensarmos no COP e no SRP, podemos observar que eles são complementares. Códigos projetados com o SRP em mente estarão bem próximos de seguir o OCP ou será bem fácil fazê-los respeitar esse princípio. Quando tempos código que tem, somente, uma razao para mudar, introduzir uma nova funcionalidade gerará uma segunda razão para mudança. Então, tanto o SRP quanto o OCP seriam violados. Da mesma forma, se tivermos código que só será alterado quando sua função principal muda e mantem-se inalterado quando novas funcionalidades são adicionadas, ele respeita o OCP e, muito provavelmente, respeitará o SRP também.</p>

<p>Isso não quer dizer que um código que segue o SRP sempre permitirá seguir o OCP ou vice e versa, mas, na maioria dos casos, se um deles é respeitado, conseguir respeitar o outro se torna bem simples.</p>

<h2>O Exemplo Óbvio de Violação do OCP</h2>

<p>De um ponto de vista, puramente, técnico, o princípio do Aberto para Extensão, Fechado para Modificação, é bem simples. Um relacionamento entre duas classes, como o que vemos logo abaixo, viola o OCP.</p>

<figure>
<img width="600" alt="violate1" src="http://cdn.tutsplus.com/net/uploads/2014/01/violate1.png" height="109"><br>
</figure>

<p>A classe <code>User</code> usa a classe <code>Logic</code> diretamente. Se precisarmos implementar uma segunda classe <code>Logic</code>, de forma que permita usar ambas as classes, atual e nova, a classe <code>Logic</code> já existente precisará mudar. <code>User</code> é diretamente ligado à implementação de <code>Logic</code>, não há outra maneira de prover uma nova classe <code>Logic</code> sem afetar a atual. E, quando falamos de linguagens fortemente tipadas, é bem possível que a classe <code>User</code> também necessite de mudanças. Se estamos falando de linguagens compiladas, é quase certo que tanto o executável, ou biblioteca dinâmica, de <code>User</code> quanto de <code>Logic</code> precisarão ser recompilados e reimplantados em nossos clientes. Um processo que queremos evitar a todo custo.</p>

<h2>Mostre-me o Código</h2>

<p>Baseado somente no esquema acima, alguém pode deduzir que qualquer classe usando diretamente outra, na verdade, viola o OCP. E isso é verdade, estrutamente falando. Percebi que é bem interessante encontrar os limites, o momento que você cria a linha e decide que é mais difícil respeitar o OCP que modificar o código existente, ou que o custo arquitetural não justifica o custo da mudança do código existente.</p>

<p>Vamos criar uma classe que provê o progresso de download de um arquivo, na forma de percentual, dentro de nossa aplicação. Nós termos duas classes principais, a classe <code>Progress</code> e a <code>File</code>, e, creio eu, que queiramos usá-las de acordo com o teste abaixo.</p>

<pre class="brush: php">function testItCanGetTheProgressOfAFileAsAPercent() {
	$file = new File();
	$file-&gt;length = 200;
	$file-&gt;sent = 100;

	$progress = new Progress($file);

	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>Nesse teste, somos um usuário da classe <code>Progress</code>. Queremos obter o valor como percentual, independente do tamanho real do arquivo. Usamos a classe <code>File</code> como fonte de informação para a classe <code>Progress</code>. Um arquivo tem um tamanho em bytes e um campo chamado <code>sent</code>, representando a quantidade de dados que já foi enviada para download. Não precisamos nos preocupar sobre como esses valores são atualizados na aplicação. Nós só precisamos acreditar que há uma mágica que faça essa lógica por nós, para que, em um teste, possamos atribuí-los manualmente.</p>

<pre class="brush: php">class File {
	public $length;
	public $sent;
}</pre>

<p>A classe <code>File</code> é só um objeto de dados com duas propriedades. Claramente, na vida real, ela conteria outras informações e comportamentos, como o nome do arquivo, os caminhos real e relativo, diretório atual, tipo, permissões e por aí vai.</p>

<pre class="brush: php">class Progress {

	private $file;

	function __construct(File $file) {
		$this-&gt;file = $file;
	}

	function getAsPercent() {
		return $this-&gt;file-&gt;sent * 100 / $this-&gt;file-&gt;length;
	}

}</pre>

<p>A classe <code>Progress</code> é bem simples e injeta uma classe <code>File</code> através de seu construtor. Para ficar claro, nós especificamos o tipo da variável nos parâmetros do construtor (injetamos uma variável daquele tipo em específico). Há um único método útil na classe <code>Progress</code>, o <code>getAsPercent()</code>, que pegará os valores que foram enviados e o tamanho do arquivo, contidos nas propriedades da classe <code>File</code>, e os transformará em percentual. Simples e funciona.</p>

<pre class="brush: bash">Testing started at 5:39 PM ...
PHPUnit 3.7.28 by Sebastian Bergmann.
.
Time: 15 ms, Memory: 2.50Mb
OK (1 test, 1 assertion)</pre>

<p>O código parece correto, porém, ele viola o OCP. Mas, por que? E como?</p>

<h2>Mudança de Requerimentos</h2>

<p>Toda aplicação a qual se esperar crescer, com o tempo será adicionada novas funcionalidades. Uma das novas funcionalidades da nossa aplicação poderia ser o *streaming* de músicas, ao invés do download dos arquivos. O tamanho de um arquivo, sendo visto através da classe <code>File</code>, é representado em bytes e a duração da música em segundos. Nós queremos oferecer uma barra de progresso bem bacana, mas, será que podemos reusar aquela que já tempos?</p>

<p>No, we can not. Our progress is bound to <code>File</code>. It understands only files, even though it could be applied to music content also. But in order to do that we have to modify it, we have to make <code>Progress</code> know about <code>Music</code> and <code>File</code>. If our design would respect OCP, we would not need to touch <code>File</code> or <code>Progress</code>. We could just simply reuse the existing <code>Progress</code> and apply it to <code>Music</code>.</p>

<h2>Solution 1: Take Advantage of the Dynamic Nature of PHP</h2>

<p>Dynamically typed languages have the advantages of guessing the types of objects at runtime. This allows us to remove the typehint from <code>Progress</code>' constructor and the code will still work.</p>

<pre class="brush: php">class Progress {

	private $file;

	function __construct($file) {
		$this-&gt;file = $file;
	}

	function getAsPercent() {
		return $this-&gt;file-&gt;sent * 100 / $this-&gt;file-&gt;length;
	}

}</pre>

<p>Now we can throw anything at <code>Progress</code>. And by anything, I mean literally anything:</p>

<pre class="brush: php">class Music {

	public $length;
	public $sent;

	public $artist;
	public $album;
	public $releaseDate;

	function getAlbumCoverFile() {
		return 'Images/Covers/' . $this-&gt;artist . '/' . $this-&gt;album . '.png';
	}
}</pre>

<p>And a <code>Music</code> class like the one above will work just fine. We can test it easily with a very similar test to <code>File</code>.</p>

<pre class="brush: php">function testItCanGetTheProgressOfAMusicStreamAsAPercent() {
	$music = new Music();
	$music-&gt;length = 200;
	$music-&gt;sent = 100;

	$progress = new Progress($music);

	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>So basically, any measurable content can be used with the <code>Progress</code> class. Maybe we should express this in code by changing the variable's name also:</p>

<pre class="brush: php">class Progress {

	private $measurableContent;

	function __construct($measurableContent) {
		$this-&gt;measurableContent = $measurableContent;
	}

	function getAsPercent() {
		return $this-&gt;measurableContent-&gt;sent * 100 / $this-&gt;measurableContent-&gt;length;
	}

}</pre>

<p>Good, but we have a huge problem with this approach. When we had <code>File</code> specified as a typehint, we were positive about what our class can handle. It was explicit and if something else came in, a nice error told us so.</p>

<pre class="brush: bash">Argument 1 passed to Progress::__construct()
must be an instance of File,
instance of Music given.</pre>

<p>But without the typehint, we must rely on the fact that whatever comes in will have two public variables of some exact names like "<code>length</code>" and "<code>sent</code>". Otherwise we will have a refused bequest.</p>

<blockquote><p>Refused bequest: a class that overrides a method of a base class in such a way that the contract of the base class is not honored by the derived class. ~Source Wikipedia.</p>
</blockquote>
<p>This is one of the <em>code smells</em> presented in much more detail in the <a href="https://tutsplus.com/course/detecting-code-smells/">Detecting Code Smells</a> premium course. In short, we do not want to end up trying to call methods or access fields on objects that do not conform to our contract. When we had a typehint, the contract was specified by it. The fields and methods of the <code>File</code> class. Now that we have nothing, we can send in anything, even a string and it would result in an ugly error.</p>

<pre class="brush: php">function testItFailsWithAParameterThatDoesNotRespectTheImplicitContract() {
	$progress = new Progress('some string');
	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>A test like this, where we send in a simple string, will produce a refused bequest:</p>

<pre class="brush: bash">Trying to get property of non-object.</pre>

<p>While the end result is the same in both cases, meaning the code breaks, the first one produced a nice message. This one, however, is very obscure. There is no way of knowing what the variable is - a string in our case - and what properties were looked for and not found. It is difficult to debug and to solve the problem. A programmer needs to open the <code>Progress</code> class and read it and understand it. The contract, in this case, when we do not explicitly specify the typehint, is defined by the behavior of <code>Progress</code>. It is an implicit contract, known only to <code>Progress</code>. In our example, it is defined by the access to the two fields, <code>sent</code> and <code>length</code>, in the <code>getAsPercent()</code> method. In real life the implicit contract can be very complex and hard to discover by just looking for a few seconds at the class.</p>

<p>This solution is recommended only if none of the other suggestions below can easily be implemented or if they would inflict serious architectural changes that do not justify the effort.</p>

<h2>Solution 2: Use the Strategy Design Pattern</h2>

<p>This is the most common and probably the most appropriate solution to respect OCP. It is simple and effective.</p>

<figure>
<img width="600" alt="strategy" src="http://cdn.tutsplus.com/net/uploads/2014/01/strategy.png" height="294"><br>
</figure>

<p>The Strategy Pattern simply introduces the use of an interface. An interface is a special type of entity in Object Oriented Programming (OOP) which defines a contract between a client and a server class. Both classes will adhere to the contract to ensure the expected behavior. There may be several, unrelated, server classes that respect the same contract thus being capable of serving the same client class.</p>

<pre class="brush: php">interface Measurable {
	function getLength();
	function getSent();
}</pre>

<p>In an interface we can define only behavior. That is why instead of directly using public variables we will have to think about using getters and setters. Adapting the other classes will not be difficult at this point. Our IDE can do most of the job.</p>

<pre class="brush: php">function testItCanGetTheProgressOfAFileAsAPercent() {
	$file = new File();
	$file-&gt;setLength(200);
	$file-&gt;setSent(100);

	$progress = new Progress($file);

	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>As usual, we start with our tests. We will need to use setters to set the values. If considered mandatory, these setters may also be defined in the <code>Measurable</code> interface. However, be careful what you put there. The interface is to define the contract between the client class <code>Progress</code> and the different server classes like <code>File</code> and <code>Music</code>. Does <code>Progress</code> need to set the values? Probably not. So the setters are highly unlikely to be needed to be defined in the interface. Also, if you would define the setters there, you would force all of the server classes to implement setters. For some of them, it may be logical to have setters, but others may behave totally differently. What if we want to use our <code>Progress</code> class to show the temperature of our oven? The <code>OvenTemperature</code> class may be initialized with the values in the constructor, or obtain the information from a third class. Who knows? To have setters on that class would be odd.</p>

<pre class="brush: php">class File implements Measurable {

	private $length;
	private $sent;

	public $filename;
	public $owner;

	function setLength($length) {
		$this-&gt;length = $length;
	}

	function getLength() {
		return $this-&gt;length;
	}

	function setSent($sent) {
		$this-&gt;sent = $sent;
	}

	function getSent() {
		return $this-&gt;sent;
	}

	function getRelativePath() {
		return dirname($this-&gt;filename);
	}

	function getFullPath() {
		return realpath($this-&gt;getRelativePath());
	}

}</pre>

<p>The <code>File</code> class is modified slightly to accommodate the requirements above. It now implements the <code>Measurable</code> interface and has setters and getters for the fields we are interested in. <code>Music</code> is very similar, you can check its content in the attached source code. We are almost done.</p>

<pre class="brush: php">class Progress {

	private $measurableContent;

	function __construct(Measurable $measurableContent) {
		$this-&gt;measurableContent = $measurableContent;
	}

	function getAsPercent() {
		return $this-&gt;measurableContent-&gt;getSent() * 100 / $this-&gt;measurableContent-&gt;getLength();
	}

}</pre>

<p><code>Progress</code> also needed a small update. We can now specify a type, using typehinting, in the constructor. The expected type is <code>Measurable</code>. Now we have an explicit contract. <code>Progress</code> can be sure the accessed methods will be always present because they are defined in the <code>Measurable</code> interface. <code>File</code> and <code>Music</code> can also be sure they can provide all that is needed for <code>Progress</code> by simply implementing all the methods on the interface, a requirement when a class implements an interface.</p>

<p>This design pattern is explained in greater detail in the <a href="https://tutsplus.com/course/agile-design-patterns/">Agile Design Patterns</a> course.</p>

<h3>A Note on Interface Naming</h3>
<p>People tend to name interfaces with a capital <code>I</code> in front of them, or with the word "<code>Interface</code>" attached at the end, like <code>IFile</code> or <code>FileInterface</code>. This is an old-style notation imposed by some outdated standards. We are so much past the Hungarian notations or the need to specify the type of a variable or object in its name in order to easier identify it. IDEs identify anything in a split second for us. This allows us to concentrate on what we actually want to abstract.</p>

<p>Interfaces belong to their clients. Yes. When you want to name an interface you must think of the client and forget about the implementation. When we named our interface Measurable we did so thinking about Progress. If I would be a progress, what would I need to be able to provide the percent? The answer is simple, something we can measure. Thus the name Measurable. </p>

<p>Another reason is that the implementation can be from various domains. In our case, there are files and music. But we may very well reuse our <code>Progress</code> in a racing simulator. In that case, the measured classes would be Speed, Fuel, etc. Nice, isn't it?</p>

<h2>Solution 3: Use the Template Method Design Pattern</h2>

<p>The Template Method design pattern is very similar to the strategy, but instead of an interface it uses an abstract class. It is recommended to use a Template Method pattern when we have a client very specific to our application, with reduced reusability and when the server classes have common behavior.</p>

<figure>
<img width="600" alt="template_method" src="http://cdn.tutsplus.com/net/uploads/2014/01/template_method.png" height="294"><br>
</figure>

<p>This design pattern is explained in greater detail in the <a href="https://tutsplus.com/course/agile-design-patterns/">Agile Design Patterns</a> course.</p>

<h2>A Higher Level View</h2>

<p>So, how is all of this affecting our high level architecture?</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2014/01/HighLevelDesign.png" height="388"><br>
</figure>

<p>If the image above represents the current architecture of our application, adding a new module with five new classes (the blue ones) should affect our design in a moderate way (red class).</p>

<figure>
<img width="600" alt="HighLevelDesignWithNewClasses" src="http://cdn.tutsplus.com/net/uploads/2014/01/HighLevelDesignWithNewClasses.png" height="410"><br>
</figure>

<p>In most systems you can't expect absolutely no effect on the existing code when new classes are introduced. However, respecting the Open/Closed Principle will considerably reduce the classes and modules that require constant change. </p>

<p>As with any other principle, try not to think about everything from before. If you do so, you will end up with an interface for each of your classes. Such a design will be hard to maintain and understand. Usually the safest way to go is to think about the possibilities and if you can determine whether there will be other types of server classes. Many times you can easily imagine a new feature or you can find one on the project's backlog that will produce another server class. In those cases, add the interface from the beginning. If you can not determine, or if you are unsure - most of the time - simply omit it. Let the next programmer, or maybe even yourself, to add the interface when you need a second implementation.</p>

<h2>Final Thoughts</h2>

<p>If you follow your discipline and add interfaces as soon as a second server is needed, modifications will be few and easy. Remember, if code required changes once, there is a high possibility it will require change again. When that possibility turns into reality, OCP will save you a lot of time and effort.</p>

<p>Thank you for reading.</p>
